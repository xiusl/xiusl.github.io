{"posts":[{"title":"大数据架构设计","text":"大数据带来的三大挑战 如何利用信息技术等手段处理非结构化和半结构化数据 如何探索大数据复杂性、不确定性特征描述的刻画方法及大数据的系统建模 数据异构性与决策异构性的关系对大数据知识发现与管理决策的影响 大数据处理系统架构特征 1.鲁棒性和容错性 2.低延迟读取和更新能力 3.横向扩容 4.通用性 5.延展性 6.即席查询能力 7.最少维护能力 8.可调试性 Lambda 架构 设计目的在于提供一个能满足大数据系统关键特性的架构，包括高容错、低延迟、可扩展 整合离线计算与实时计算，融合不可变性、读写分离和复杂性隔离等原则 是用于同时处理离线数据和实时数据的、可容错的、可扩展的分布式系统 具备强鲁棒性，提供低延迟和持续更新 应用场景：机器学习、物联网、流处理 架构可分解为三层：批处理层、加速层、服务层 批处理层（Batch Layer）：存储数据集，在数据集上预先计算查询函数，并后见查询对应的View可以很好处理离线数据根据全体离线数据直接得到 Batch View 加速层（Speed Layer）：处理的是最近增量数据流，为了效率，在接受到新的数据后会不断更新 Real-tiem View 服务层（Serving Layer）：合并Batch View 和 Real-time View 中的结果数据集到最终数据集，用于响应用户的查询请求 在这种Lambda 架构中 Hadoop (HDFS) 用于存储主数据集 Spark（或Storm) 可构成速度层 HBase（或Cassandra) 作为服务层，由Hive创建可查询的视图 Hadoop 是适合运行在通用硬件上的分布式文件系统。HDFS 是一个具有高度容错性的系统，能够提供高吞吐量的数据访问，非常适合大规模数据集上的应用Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎，中间数据结果可以保存在内存，能更好的适用于数据挖掘与机器学习等需要迭代的 Map Reduce 算法HBase-Hadoop Database 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，可在廉价PCServer上搭建起大规模结构化存储集群 Lambda 架构的优点：容错性好、查询灵活度高、易伸缩、易扩展缺点：全场景覆盖带来的编码开销（需要同时维护一套实时计算和一套存量计算代码），针对具体场景重新离线训练一遍的益处不大，重新部署和迁移成本很高。 事件溯源（Event Sourcing）与 Lambda 架构Event Sourcing 本质上是一种数据持久化的方式，其由三个核心观点构成1）整个系统以事件为驱动，所有事物都由事件驱动来完成2）事件是核心。系统的数据以事件为基础，事件要保存在某种存储上3）业务数据只是一些由事件产生的视图，不一定要保存到数据库中Lambda 中对数据集存储使用的概念月 Event Sourcing 中的思想完全一致，使用统一的数据模型对数据处理事件本身进行定义发生错误的时候，能够通过模型找到错误发生的原因，对这一事件进行重新计算，恢复系统的正确状态，实现了容错性 CQRS 与 Lambda 架构CQRS 架构分离了对数据进行的读操作和写操作，将能够改变数据模型状态的命令与模型状态查询操作实现了分离，是领域驱动设计的一个架构模式，解决数据库报表的输出处理方式Lambda 架构中，数据的修改通过批处理和流处理实现，通过写操作将数据转换成查询时所对应的View，对数据查询时是通过 View 直接得到结果，实际上是一种形式的读写分离 Kappa 架构在 Lambda 架构的基础上进行了优化，删除了 Batch Layer 的架构，将数据通道以消息队列进行替代依旧以流处理为主，数据在数据湖面进行了存储，需要进行离线分析或再次计算时，将数据湖的数据再次经过消息队列重播一次输入数据直接由实时层的实时数据处理引擎对源源不断的源数据进行处理 从使用场景上对比：1）Kappa 不是 Lambda 的替代架构，而是其简化版本，Kappa 放弃了对批处理的支持，更擅长业务本身为增量数据写入场景的分析需求2）Lambda 直接支持批处理，更适合对历史数据分析查询的场景 Kappa 架构的优点：将实时和离线代码统一起来缺点：1）消息中间件缓存数据量和回溯数据由性能瓶颈2）遇到大量不同实时流进行关联时，非常依赖实时计算系统的能力，很可能因为数据流先后顺序问题，导致数据丢失3）抛弃了离线计算更加稳定可靠的特点 Kappa+ 架构流式数据处理架构，核心思想是让流计算框架直接读 HDFS 里的数据仓库数据，一并实现实时计算和历史数据 backfll 计算将不同源的数据通过 Kafka 导入到 Hadoop 中，通过 HDFS 来存储中间数据，再通过 spark 对数据进行分析处理，最后交由上层业务查询 混合分析系统的Kappa架构Lambda 和 Kappa 都有展示层的困难点，如何支持热点数据的查询分析，解决方案是在 Kappa 基础上衍生数据分析流程基于 Kafka + Flink 构建 Kappa 流计算数据架构，针对 Kappa 分析能力不足，利用 Kafka 对接 ES 实时分析引擎，部分弥补其数据分析能力但 ES 也只适合对合理数据量级的热点数据进行索引，无法覆盖所有批处理相关的分析需求，是 Kappa 和 lambda 的折中方案 对比和选择1）业务需求与技术要求： 业务对与 Hadoop、Spark、Strom 等关键技术由强制依赖选择 lambda 处理数据偏好于流式计算，依赖 Flink 计算引擎，选择 Kappa2）复杂度 项目中频繁对算法模型参数进行修改，算法模型支持同时执行批处理和流式计算，系统用一份代码进行数据处理 Kappa3）开放维护成本 lambda 需要有一定程度的开发维护成本，包括了两套系统的开发、部署、测试、维护 Kappa 只需要维护一套系统4）历史数据处理能力 频繁接触海量数据集进行分析，lambda 始终使用小规模数据集，流处理系统完全可是使用，选择 Kappa","link":"/2024/10/16/19%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"gitea 的使用","text":"搭建自己的 git 仓库，使用 gitea 使用 dockerdocker-compose.yml 文件 123456789101112131415161718192021222324252627282930version: &quot;3&quot;networks: gitea: external: falseservices: server: image: gitea/gitea:1.19.3 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 - GITEA__database__DB_TYPE=mysql - GITEA__database__HOST=192.168.0.36:3306 - GITEA__database__NAME=gitea - GITEA__database__USER=gitea - GITEA__database__PASSWD=gitea110 - DOMAIN=192.168.0.36:8030 - SSH_DOMAIN=192.168.0.36:222 restart: always networks: - gitea volumes: - ./giteadata:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - &quot;8030:3000&quot; - &quot;222:22&quot; 注意⚠️：一定要把数据挂在到主机上，不然会导致数据丢失 12volumes: - ./giteadata:/data gitea 1.19.3支持作为包管理仓库 gitea packages 支持类似于 github 的 action gitea actions 简单的应用下载对应的 act_runner，地址 act_runner download 注册并启动 123./act_runner register --no-interactive --instance &lt;instance&gt; --token &lt;token&gt;./act_runner daemon 创建一个 Spring demo 项目，在项目中新建 gitea/workflows/deploy.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475name: Gitea Maven Demorun-name: ${{ gitea.actor }} 🚀on: [push]jobs: Explore-Gitea-Actions: runs-on: ubuntu-latest container: # 带有 docker 环境的容器 image: catthehacker/ubuntu:act-latest # 持久化工具目录 volumes: - ubuntu_hostedtoolcache:/opt/hostedtoolcache steps: - uses: actions/checkout@v3 # 下载 java JDK 8 - run: | download_url=&quot;http://192.168.0.35:5244/d/mac/OpenJDK8U-jdk_x64_linux_hotspot_8u372b07.tar.gz&quot; wget -O $RUNNER_TEMP/java_package.tar.gz $download_url # 设置 java 环境 - name: Set up JDK 8 uses: actions/setup-java@v3 with: java-version: '8' distribution: 'jdkfile' jdkFile: ${{ runner.temp }}/java_package.tar.gz cache: 'maven' # 配置 maven - name: Set up Maven uses: http://192.168.0.36:8030/actions/setup-maven@v4.7 with: maven-version: 3.8.2 - name: maven-settings-xml-action uses: http://192.168.0.36:8030/actions/maven-settings-xml-action@v20 with: repositories: | [ { &quot;id&quot;: &quot;aliyunpublic&quot;, &quot;name&quot;: &quot;aliyun Public&quot;, &quot;url&quot;: &quot;https://maven.aliyun.com/repository/public&quot;, &quot;releases&quot;: { &quot;enabled&quot;: &quot;true&quot; }, &quot;snapshots&quot;: { &quot;enabled&quot;: &quot;true&quot; } } ] mirrors: &gt; [ { &quot;id&quot;: &quot;aliyunpublic&quot;, &quot;mirrorOf&quot;: &quot;*&quot;, &quot;url&quot;: &quot;https://maven.aliyun.com/repository/public&quot; } ] # mvn build - name: Build with Maven run: mvn clean package # gitea docker registry login - name: Login to GitHub Container Registry uses: docker/login-action@v2 with: registry: 192.168.0.36:8030 username: xiusl password: ${{ security.REGISTRY_PWD }} # docker build and push - name: Build docker run: | docker build -t 192.168.0.36:8030/xiusl/demo:latest . docker push 192.168.0.36:8030/xiusl/demo:latest ⚠️ 本地的 docker registry 没有 https，因此在 docker 的 daemon.json 中需要增加信任 12345{&quot;insecure-registries&quot;: [ &quot;192.168.0.36:8030&quot; ]}","link":"/2023/05/15/230516-gitea-use/"},{"title":"git 的使用","text":"记录 git 的一些使用方法 提交部分文件1234567891011# 添加需要提交的文件git add dir/file# 忽略其他文件git stash -u -k# 提交信息git commit -m &quot;xxxxx&quot;# 恢复git stash pop git stash 的使用 1234567891011121314151617181920212223# 保存草稿并添加备注，有了备注可以方便查找git stash save &quot;message&quot;# 查看已经保存的草稿git stash list# 查看草稿的改动git stash show# 查看第 n 个草稿git stash show stash@{n}# 应用某个草稿，不会在草稿列表删除，默认是第一个，使用 stash@{n} 来指定第几个git stash apply# 应用某个草稿，并在草稿列表删除，默认是第一个，使用 stash@{n} 来指定第几个git stash pop # 删除某个草稿git stash drop stash@{n} # 清理所有草稿git stash clear","link":"/2023/05/17/230517-gituse/"},{"title":"部署自己的 sentry 服务","text":"自建 sentry 服务，作为错误信息监控。采用的是旧的 9.1.2 版本，如需最新版本，参考官方文档。 推荐在 Debain 系统上进行部署，之前使用了 REHL 系列的系统，self-hosted-912-web 服务会分配和占用很大的内存，具体什么原因还不清楚。 主机上需要安装好 docker 服务 在 github 上下载官方提供的部署脚本（附：下载地址），解压文件。 由于目前安装的 docker compose 是最新的版本，需要修改 install.sh 中的部分代码，主要是替换 docker-compose 为 docker compose，完成代码参考 install.sh 12345678# line 24: get docker compose versionCOMPOSE_VERSION=$(docker compose version --short || echo '')# line 68: docker-compose to docker composeSECRET_KEY=$(docker compose run --rm web config generate-secret-key 2&gt; /dev/null | tail -n1 | sed -e 's/[\\/&amp;]/\\\\&amp;/g')# line 75, 83: docker-compose to docker compose# ... 执行修改后的 install.sh 脚本 1./install.sh 脚本执行过程中会提示是否创建 sentry 账号，可以选择在这个地方创建 脚本执行完成后，启动服务 1docker compose up -d 查询服务状态，正常会有以下 7 个服务运行 12345678CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9b1e803d7dcf self-hosted-912-worker &quot;/entrypoint.sh run …&quot; 15 hours ago Up 15 hours 9000/tcp self-hosted-912-worker-16b4977a45949 self-hosted-912-web &quot;/entrypoint.sh run …&quot; 15 hours ago Up 15 hours 0.0.0.0:9000-&gt;9000/tcp, :::9000-&gt;9000/tcp self-hosted-912-web-1199f1760fc26 self-hosted-912-cron &quot;/entrypoint.sh run …&quot; 15 hours ago Up 15 hours 9000/tcp self-hosted-912-cron-11d2cf8c084ce postgres:9.5 &quot;docker-entrypoint.s…&quot; 15 hours ago Up 15 hours 5432/tcp self-hosted-912-postgres-1b0d87c431e33 memcached:1.5-alpine &quot;docker-entrypoint.s…&quot; 15 hours ago Up 15 hours 11211/tcp self-hosted-912-memcached-10b0077bfe895 redis:3.2-alpine &quot;docker-entrypoint.s…&quot; 15 hours ago Up 15 hours 6379/tcp self-hosted-912-redis-10e90ca779b36 tianon/exim4 &quot;docker-entrypoint.s…&quot; 15 hours ago Up 15 hours 25/tcp self-hosted-912-smtp-1 通过网页打开 http://your-host-ip:9000 登录创建好的账号就可以使用了 可以在前面加一层 nginx 代理，实现自定义域名和 https 访问 12345678910111213141516171819202122server{ listen 80; listen 443 ssl; server_name sentry.you-domain.com; ssl_certificate cert/you-domain.crt; ssl_certificate_key cert/you-domain.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_pass http://127.0.0.1:9000; }} linux 增加 swap 空间 1234567891011121314# 分配空间fallocate -l 8G /swapspace# 增加权限chmod 600 /swapspace# 格式化文件mkswap /swapspace# 启用交换空间swapon /swapspace# 开启自动启动echo &quot;/swapspace swap swap defaults 0 0&quot; | tee -a /etc/fstab# 检查是否生效swapon --showfree -h","link":"/2023/07/01/230701-self-host-sentry/"},{"title":"be-hacker","text":"读了一片如何成为一名黑客的文章，觉得对技术学习用帮助，把一些内容摘录在这里。原文译文在下面的链接。 如何成为一名黑客 你必须建立对于自己学习能力的信念——就算你掌握的知识不足以解决当前的问题，如果你从问题的一小部分下手并从中学习，你将学到足够的知识用来解决下一部分——以此类推，直到整个问题都被你解决为止。 学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点……如此往复，直到你的文章具备范文的力量和感觉为止。 黑客的基本技能 学习如何编程。 学习使用开源 Unix 系统。 学会使用万维网以及编写 HTML。 学习英语，如果你的水平不够用的话。 TODO 学会用母语流畅地写作。尽管很多人认为程序员写不出好文章，但是有相当数量的黑客（包括所有我知道的最棒的黑客）都是很有能力的写手。 阅读科幻小说。参加科幻小说讨论会。（这是一个认识黑客和准黑客的好方法） 学习一种武术。武术中需要的精神自律能力和黑客在这方面的需求非常相似。黑中最受欢迎的武术是来自亚洲的空手格斗类武术，例如跆拳道、空手道、武术、合气道、柔术等。西式击剑和亚洲剑术也有不少的跟随者。1990 年后期以来，在可以合法使用枪支的地方，射击受欢迎的程度也越来越高了。大部分黑客喜欢的武术类型都是那些强调精神的自律，放松的意识，以及意念的控制，而不仅仅是单纯的力量、运动精神、以及身体的强健。 实实在在学习一种冥想修炼。多年以来黑客中最受欢迎的形式是参禅。（很重要的一点是，参禅和宗教可以说是独立的，你不需要接受一种新宗教，或者放弃现有的宗教信仰，就能做参禅的修炼。其他的形式也许也管用，但注意一定要挑那些靠谱的，不需要你相信不着边际的事物的冥想方式来演练。 提高自己对双关语和文字游戏的鉴赏能力。 NOTDO 不要使用愚蠢的，哗众取宠的ID或昵称。 不要卷入 Usenet（或任何其他地方）的骂战。 不要自称为“cyberpunk（网络朋克）”，也不要浪费时间和那些人打交道。 不要让你的 email 或者帖子中充满错误的拼写和语法。 Python，Java，C/C++，Perl 和 LISP Unix think: 讲到的一些东西并不局限于如何成为黑客。","link":"/2017/06/28/be-hacker/"},{"title":"block &amp; delegate &amp; notification 特点和区别","text":"iOS 中三种回调的特点、区别和使用场景的总结。 特点和区别 block 简单易用，可以直接访问上下文的变量，不需要额外存储临时变量，代码阅读连续。 delegate 比较复杂，需要声明和实现接口，而且两者不在同一文件中，需要跳转文件，还可能需要存储临时变量。 notification 较为复杂，需要定义通知类型，同样通知的发送和接收不在一个文件中。 问题 block 虽然简单，但会存在循环引用的问题。 delegate 需要对方法进行检验 respondsToSelector:。 notification 需要注意他的多对多特性，通知的移除（iOS 9 之后不需要？）。 delegate 的运行成本低，block 的运行成本高，block 在出栈的时候需要将使用的数据从栈区拷贝到堆区，而 delegate 只是保存一个指针而已。 场景 当只有1、2个回调时使用 block，3个以上的话使用 delegate。 避免循环引用的时候使用 delegate。 根据回调的性质来选择 回调不定期触发，或者会多次触发，delegate 更加合适。 回调是一次性的，单线性（一对一这种）的关系，block 更加合适。 回调是广播性质的，需要多个类同时收到，notification 更加合适。 总结 通过不同执行线（一对一，一对多）、不同的执行次数、不同的执行数量来判断使用哪一种回调。 参考 https://www.zhihu.com/question/29023547https://blog.csdn.net/u010670946/article/details/71340711","link":"/2019/04/02/block-delegate-notification/"},{"title":"centos-flask-nginx","text":"在 centos7 上使用 nginx + uwsgi 部署 flask 应用 安装 zsh 和 ohmyzsh 12yum install -y zshsh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 安装一些需要的库 123yum groupinstall -y &quot;Development tools&quot;yum install -y zlib-devel bzip2-devel pcre-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel 安装 Python3，这里编译安装，也可以使用 yum 来安装 1234567891011wget http://python.org/ftp/python/3.7.1/Python-3.7.1.tar.xzxz -d Python3.7.1.tar.xztar -xvf Python3.7.1.tarcd Python3.7.1./configure --prefix=/usr/localmake &amp;&amp; make install 建立软连接 123ln -s /usr/local/bin/python3 /usr/bin/python# ln: 无法创建符号链接&quot;/usr/bin/python&quot;: 文件已存在# rm /usr/bin/python 修复 yum、firewall-cmd 等 123456vim /usr/bin/yum#! /usr/bin/python =&gt; /usr/bin/python2vim /usr/libexec/urlgrabber-ext-down#! /usr/bin/python =&gt; /usr/bin/python2vim vim /usr/bin/firewall-cmd#!/usr/bin/python -Es =&gt; #!/usr/bin/python2 -Es 安装 uwsgi 1pip3 install uwsgi 安装 Python 虚拟环境 virtualenv 1pip3 install virtualenv 根目录下创建工作文件夹，虚拟环境 12345cd /mkdir projectcd projectvirtualenv env --python=/youpython3path/python3source env/bin/activate 安装 flask 12echo flask &gt; requirements.txtpip install -r requirements.txt 创建一个简单flask 应用 vim manage.py 1234567from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def index(): return &quot;Hello&quot; 创建 uwsgi 配置文件 uwsgi.ini 123456789101112131415161718[uwsgi]socket = 127.0.0.1:9090master = truevhost = trueno-stie = trueworkers = 2reload-mercy = 10vacuum = truemax-requests = 1000limit-as = 2048buffer-size = 30000daemonize = /var/log/uwsgi.logchdir = /projectvirtualenv = /project/envwsgi-file = manage.pycallable = apppidfile = /run/uwsgi.pid 安装 nginx 1yum install -y nginx 修改 nginx 配置 vim /etc/nginx/nginx.conf 12345678910111213141516171819202122server { listen 80 default_server; listen [::]:80 default_server; server_name _;# root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { uwsgi_pass 127.0.0.1:9090; include uwsgi_params; }# error_page 404 /404.html;# location = /40x.html {# }# error_page 500 502 503 504 /50x.html;# location = /50x.html {# }} 测试 nginx 配置是否正确 nginx -t 12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful nginx 一些操作 12nginxnginx -s reload 开启 uwsgi 1uwsgi -i /etc/uwsgi.ini 重启 uwsgi 1uwsgi --reload run/uwsgi.pid","link":"/2019/01/21/centos-flask-nginx/"},{"title":"datastruct-pycook","text":"python cookbook datastruct 解压序列赋值给多个变量 变量的个数和序列元素的个数不匹配 只解压一部分1234data = [&quot;abc&quot;, 10, 22.1, (2018, 12, 12)]_, shares, prices, _= dataprint(shares) # 10print(prices) # 22.1 解压可迭代对象赋值给多个变量 星号(*)表达式12345record = ('Dave', 'dave@example.com', '213-123-1421', '312-423-1511')name, email, *phone_numbers = recordprint(name) # Daveprint(email) # deve@example.comprint(phone_numbers) # ['213-123-1421', '312-423-1511'] 星号表达式解压出来的永远是列表类型 迭代元素为可变长元组的序列1234567891011121314151617records = [ ('foo', 1, 2), ('bar', 'hello'), ('foo', 3, 5)]def do_foo(x, y): return x+ydef do_bar(str): print(str)for tag, *args in records: if tag == 'foo': do_foo(*args) elif tag == 'bar': do_bar(*args) 星号表达式操作字符chuan12345line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'uname, *fields, homedir, sh = line.split(':')print(uname) # 'nobody'print(homedir) # '/var/empty'print(sh) # '/usr/bin/false' 解压并丢弃一些元素， _ or ign(ignore)1234record = ('abc', 12, 23.1, (12, 12, 2018))name, *_, (*_, year) = recordprint(name) # 'abc'print(year) # 2012 保留最后 N 个元素 保留有限历史记录 collections.deque12345678910111213141516from collections import dequedef search(lines, pattern, history=5): previous_lines = deque(maxlen=history) for line in lines: if pattern in line: yield line, previous_lines previous_lines.append(line)if __name__ == '__main__': with open(r'../../cookbook/somefile.txt') as f: for line, prevlines in search(f, 'python', 5): for pline in prevlines: print(pline, end='') print(line, end='') print('-' * 20) deque(maxlen=N) 会创建一个固定大小的队列，当新的元素加入并且队列已满的时候，最老的元素会自动被移除1234567q = deque(maxlen=3)q.append(1)q.append(2)q.append(3)print(q) # deque([1, 2, 3], maxlen=3)q.append(4)print(q) # deque([2, 3, 4], maxlen=4) deque() 不设置最大长度，将会创建一个无限大小队列，可以在两端增删元素1234567891011q = deque()q.append(1)q.append(2)q.append(3)print(q) # deque([1, 2, 3])q.appendleft(4)print(q) # deque([4, 1, 2, 3])q.pop()print(q) # deque([4, 1, 2])q.popleft()print(q) # deque([1, 2]) 查找最大或最小的 N 个元素 heapq 模块的 nlargest() 和 nsmallest() 两个函数 函数可以接受一个关键字参数，用于复杂的数据结构12345678910111213141516import heapqnums = [1, 8, 3, 23, 4, -1, 12, 34, 54, 3]print(heapq.nlargest(3, nums)) # [54, 34, 23]print(heapq.nsmallest(3, nums)) # [-1, 1, 3]portfolio = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.69}]cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price']) 函数的底层实现是将集合进行堆排序再放入列表中 堆排序的特征是 heap[0] 始终是最小的元素 … 查找元素个数相对比较少的时候，函数 nlargest() 和 nsmallest() 是很合适的 如果你仅仅查找唯一的最小或最大的元素的话，使用 min() 和 max() 会更快一些 如果查找元素的个数和集合的大小接近的话，通常先排序这个集合然后在使用切片操作会更快 实现优先级队列 使用 heapq 实现简单的优先级队列123456789101112131415161718192021222324252627282930import heapqclass PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1]class Item: def __init__(self, name): self.name = name def __repr__(self): return 'Item({!r})'.format(self.name)q = PriorityQueue()q.push(Item('foo'), 1)q.push(Item('bar'), 5)q.push(Item('spam'), 4)q.push(Item('grok'), 1)print(q.pop())print(q.pop())print(q.pop())print(q.pop()) 字典排序 使用 collections 模块中的 OrderedDict 类，控制一个字典中元素的顺序12345678910from collections import OrderedDictd = OrderedDict()d['foo'] = 1d['bar'] = 2d['spam'] = 3d['grok'] = 4for key in d: print(key, d[key]) 当需要序列化或编码成其他格式的映射的时候，OrderedDict 是非常有用的。例如精确控制 JSON 编码后字段的顺序12import jsonjson.dumps(d) OrderedDict 的内部维护着一个很具键插入顺序排序的双向链表。每次一个新元素插入的时候，它会放到链表的尾部。对一个已经存在的键的重复赋值不会改变键的顺序 一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护这另一个链表，当在处理大量数据的时候需要考虑内存消耗 字典的运算 字典中执行运算操作，最值、排序等 使用 zip() 函数将键和值翻转123456789prices = { 'ACME': 45.23, 'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}min_price = min(zip(prices.values(), prices.keys()))max_price = max(zip(prices.values(), prices.keys())) 类似的可以使用 sorted() 函数来排序字典数据 需要注意 zip() 函数创建的是一个只能访问一次的迭代器123prices_and_names = zip(prices.values(), prices.keys())print(min(prices_and_name))print(max(Prices_and_name)) # ValueError max arg is an empty sequence 在一个字典上执行普通的数学运算，只会作用在键上12min(prices) # 'AAPL'max(prices) # 'IBM' 当考虑使用 values() 方法解决的时候，无法获取对应键的信息12min(prices.values()) # 10.75max(prices.values()) # 612.78 使用 min() 和 max() 函数中的参数 key 可以获取对应的键的信息，但又无法一次性获取对应值得信息1234min(prices, key=lambda k: prices[k]) # 'FB'max(prices, key=lambda k: prices[k]) # 'AAPL'min_value = prices[min(prices, key=lambda k: pirces[k])] 在使用(值,键)对的时，多个实体拥有相同值得时候，键会决定返回结果123prices = {'AAA': 45.23, 'ZZZ', 45.23}min(zip(prices.values(), prices.keys())) # (45.23, 'AAA')max(zip(prices.values(), prices.keys())) # (45.23, 'ZZZ') 查找两个字典的相同点 通过集合操作来获取字典相同的键、相同的值12345a = {'x': 1, 'y': 2, 'z': 3}b = {'w': 10, 'x': 11, 'y': 2}print(a.keys() &amp; b.keys()) # {'x', 'y'}print(a.keys() - b.keys()) # {'z'}print(a.items() &amp; b.items()) # {('y', 2)} 修改或过滤字典元素12c = { key:a[key] for key in a.keys() - {'z', 'w'}}print(c) # {'x': 1, 'y': 2} 字典的键可以直接执行集合的运算操作，不需要转换为 set 字典的值是不支持直接进行集合操作的，需要转换为 set 才可以 删除序列相同元素并保持顺序 序列上的值都是 hashable 类型，可以使用集合或者生成器来解决123456789def dedupe(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)a = [1, 5, 2, 1, 9, 1, 5, 10]print(list(dedupe(a)) # [1, 5, 2, 9, 10] 元素不可以哈希时12345678910111213def dedupe(items, key=None): seen = set() for item in items: val = item if key is None else key(item) if val not in seen: yield item seen.add(val)a = [{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 1,'y': 2}, {'x': 2, 'y': 4}]print(list(dedupe(a, key=lambda d: (d['x'], d['y']))))# [{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]print(list(dedupe(a, key=lambda d: d['x'])))# [{'x': 1, 'y': 2}, {'x': 2, 'y': 4}] 命名切片 硬编码切片下标（固定字符串提取指定位置的字段）123456record = '...............100.........513.25.........'cost = int(record[15:18]) * float(record[27:33])SHARES = slice(15, 18)PRICE = slice(27, 33)cost = int(record[SHARES]) * float(record[PRICE]) 内置的 slice() 函数创建一个切片对象，可以被用在任何允许使用切片的地方12345678items = [0, 1, 2, 3, 4, 5, 6]a = slice(2, 4)print(items[2:4]) # [2, 3]print(items[a]) # [2, 3]items[a] = [10, 11]print(items[a]) # [10, 11]del items[a]print(items) # [0, 1, 4, 5, 6] 切片对象的属性可以获取相应的信息1234a = slice(5, 50, 2)print(a.start) # 5print(a.stop) # 50print(a.step) # 2 切片对象的 indices(size) 方法可以将它映射到一个确定大小的序列上1234567s = 'HelloWorld'print(a.indices(len(s))) # (5, 10, 2)for i in range(*a.indices(len(s))): print(s[i])# W# r# d","link":"/2019/01/12/datastruct-pycook/"},{"title":"宏和常量（Objective-C）","text":"对于宏、常量使用的一些笔记 宏 定义 123#define 宏名 语句#define PI 3.1415 在程序的预处理阶段，所有使用宏的地方，都会被宏名后面的语句替换 多行的情况使用反斜线\\链接 12#define SOME &quot;too many \\chars&quot; 命名是使用大写字母 带有参数的宏 1#define ANHLE2RADIAN(a) (PI*(a)/108) 可变宏...、__VA_ARGS__ 1#define LOG(x, ...) NSLog(x, ##__VA_ARGS__) 括号() 常量 使用 const 修饰 只会分配一块空间 会进行类型检查 不能定义方法 const 位置，一般使用第三种方法定义 123456// *BaseUrl 不能修改，BaseUrl 可以修改const NSString *BaseUrl = @&quot;http://api.someweb.com&quot;;// *BaseUrl 不能修改，BaseUrl 可以修改NSString const *BaseUrl = @&quot;http://api.comeweb.com&quot;;// *BaseUrl 可以修改，BaseUrl 不能修改NSString *const BaseUrl = @&quot;http://api.comeweb.com&quot;; 在.h中使用extern提供给外部使用 比较 尽量多使用常量来替换宏定义，在使用宏的时候思考是否可以使用常量来替换 宏在预处理阶段会进行文本替换，在宏修改后会重新编译，影响编译速度 大量的使用宏会增大二进制文件的大小 宏可以定义一些方法 宏可以重定义，xCode会提示警告","link":"/2018/08/15/define-const/"},{"title":"Xcode12 模拟器编译报错","text":"项目代码在 Xcode 12 版本模拟器编译报错记录 报错信息No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=armv7 armv7s arm64). 原因分析Xcode 12 去掉了 Valid Architectures，模拟器的指令集为 x86_64 解决方法在 Build Setting -&gt; User-Defined -&gt; VALID_ARCHS 增加 x86_64 关于指令集 1234567891011arm64: iPhone6s, iphone6s plus, iPhone6, iPhone6 plus, iPhone5Sarmv7s: iPhone5, iPhone5Carmv7: iPhone4, iPhone4Si386 是针对 intel 通用微处理器32位处理器x86_64 是针对 x86 架构的64位处理器模拟器32位处理器测试需要 i386 架构模拟器64位处理器测试需要 x86_64 架构真机32位处理器需要 armv7,或者 armv7s 架构真机64位处理器需要 arm64 架构","link":"/2020/09/27/fix-xcode12/"},{"title":"git ssh 的配置","text":"git ssh 的配置，多个 git 仓库 ssh key 配置生成 SSH key1ssh-keygen -t rsa -C &quot;xiushilin@hotmail.com&quot; 多个 git 服务器 新建 ~/.ssh/config 1234567891011121314Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsaHost git.dev.tencent.com HostName git.dev.tencent.com User git IdentityFile ~/.ssh/tencent_rsaHost git2.dev.tencent.com HostName git.dev.tencent.com User git IdentityFile ~/.ssh/tencent2_rsa Host 别名，clone时替换为这个 HostName git仓库的地址 User 一般为git IdentityField 公钥文件 测试 123ssh -T git@github.comssh -T git@git.dev.tencent.comssh -T git@git2.dev.tencent.com","link":"/2019/04/29/git-ssh-config/"},{"title":"gRPC 笔记 - 一元RPC","text":"需要做的 定义一个 proto 服务，包含创建一台便携计算机的一元 RPC 实现一个服务器来处理请求，并将信息保存到内存中 实现一个客户端去调用这个服务 为客户端和服务端的交互编写单元测试 学习如何处理错误，返回对应的错误码，和 gRPC 的 deadline 定义 proto 服务 在 proto 目录下新建 laptop_service.proto，定义一个 laptop 服务。 包括了一个请求消息，一个响应消息，在服务里有一个创建 laptop 的声明 1234567891011message CreateLaptopRequest { Laptop laptop = 1;}message CreateLaptopResponse { string id = 1;}service LaptopServices { rpc CreateLaptop(CreateLaptopRequest) returns (CreateLaptopResponse) {}} 执行 make gen，在 pd 目录下将生成一个 laptop_service.pb.go 文件，一些内容如下 123456789101112type CreateLaptopRequest struct { // ... Laptop *Laptop `protobuf:&quot;bytes,1,opt,name=laptop,proto3&quot; json:&quot;laptop,omitempty&quot;`}type CreateLaptopResponse struct { // ... Id string `protobuf:&quot;bytes,1,opt,name=id,proto3&quot; json:&quot;id,omitempty&quot;`}// LaptopServicesServer is the server API for LaptopServices service.type LaptopServicesServer interface { CreateLaptop(context.Context, *CreateLaptopRequest) (*CreateLaptopResponse, error)} 定义一个服务器 在 service 中新建一个 laptop_server.go 文件 定义一个 LaptopServer 123456789type LaptopServer struct { store LaptopStore}func NewLaptopServer() *LaptopServer { return &amp;LaptopServer{ store: NewInMemoryLaptopStore(), }} LaptopServer 包含了一个 laptop 存储接口，在 service 中创建 laptop_store.go 123type LaptopStore interface { Save(laptop *pb.Laptop) error} 在 laptop_store.go 中，新建 LaptopStore 的内存存储实现 ImMemoryLaptopStore 123456789101112type InMemoryLaptopStore struct { mu sync.Mutex data map[string]*pb.Laptop}func NewInMemoryLaptopStore() *InMemoryLaptopStore { //...}func (store *InMemoryLaptopStore) Save(laptop *pb.Laptop) error { // ...} 实现 RPC 的 CreateLaptop 方法 123func (server *LaptopServer) CreateLaptop(ctx context.Context, req *pb.CreateLaptopRequest) (*pb.CreateLaptopResponse, error) { // ...} 编写单元测试 在 service 中创建 laptop_server_test.go ，编写测试用例 123456789101112131415161718192021222324252627282930313233343536373839404142laptopNoID := &amp;pb.Laptop{}laptopNoID.Id = &quot;&quot;laptopInvalidID := &amp;pb.Laptop{}laptopInvalidID.Id = &quot;invalid-id&quot;laptopDuplicateID := sample.NewLaptop()storeDuplicateID := service.NewInMemoryLaptopStore()err := storeDuplicateID.Save(laptopDuplicateID)require.NoError(t, err)testCases := []struct { name string laptop *pb.Laptop store service.LaptopStore code codes.Code }{ { name: &quot;success_with_id&quot;, laptop: sample.NewLaptop(), store: service.NewInMemoryLaptopStore(), code: codes.OK, }, { name: &quot;success_no_id&quot;, laptop: laptopNoID, store: service.NewInMemoryLaptopStore(), code: codes.OK, }, { name: &quot;failure_invalid_id&quot;, laptop: laptopInvalidID, store: service.NewInMemoryLaptopStore(), code: codes.InvalidArgument, }, { name: &quot;failure_duplicate_id&quot;, laptop: laptopDuplicateID, store: storeDuplicateID, code: codes.AlreadyExists, }, } 测试 1234567891011121314151617181920212223242526272829for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { req := &amp;pb.CreateLaptopRequest{ Laptop: tc.laptop, } srv := service.NewLaptopServer(tc.store) resp, err := srv.CreateLaptop(context.Background(), req) if tc.code == codes.OK { require.NoError(t, err) require.NotNil(t, resp) fmt.Println(tc.laptop.Id) fmt.Println(resp) require.NotEmpty(t, resp.Id) if len(tc.laptop.Id) &gt; 0 { require.Equal(t, resp.Id, tc.laptop.Id) } } else { require.Error(t, err) require.Nil(t, resp) st, ok := status.FromError(err) require.True(t, ok) require.Equal(t, tc.code, st.Code()) } })} 编写 客户端测试 在 service 创建 laptop_client_test.go ，创建测试方法 123func TestClientCreateLaptop(t *testing.T) { // ...} 启动一个 grpc 服务器，添加 startTestLaptopServer 函数，返回一个 kaotop 服务，和服务的地址 12345678910111213func startTestLaptopServer(t *testing.T) (*service.LaptopServer, string) { laptopServer := service.NewLaptopServer(service.NewInMemoryLaptopStore()) grpcServer := grpc.NewServer() pb.RegisterLaptopServicesServer(grpcServer, laptopServer) listen, err := net.Listen(&quot;tcp&quot;, &quot;:0&quot;) require.NoError(t, err) go grpcServer.Serve(listen) return laptopServer, listen.Addr().String()} 创建一个 grpc 客户端，添加 newTestLaptopClient 函数，根据 addr 地址，返回 LaptopServicesClient 对象 12345func newTestLaptopClient(t *testing.T, addr string) pb.LaptopServicesClient { conn, err := grpc.Dial(addr, grpc.WithInsecure()) require.NoError(t, err) return pb.NewLaptopServicesClient(conn)} 完善测试代码 1234567891011121314151617181920212223func TestClientCreateLaptop(t *testing.T) { laptopServer, serverAddr := startTestLaptopServer(t) laptopClient := newTestLaptopClient(t, serverAddr) laptop := sample.NewLaptop() expectedID := laptop.Id req := &amp;pb.CreateLaptopRequest{ Laptop: laptop, } resp, err := laptopClient.CreateLaptop(context.Background(), req) require.NoError(t, err) require.NotNil(t, resp.Id) require.Equal(t, resp.Id, expectedID) other, err := laptopServer.Store.FindByID(expectedID) require.NoError(t, err) require.NotNil(t, other.Id) require.Equal(t, other.Id, expectedID) requireSameLaptop(t, other, laptop)} LaptopStore 需要新增一个函数 FindByID，来验证是否存储成功，编辑 laptop_store.go 12345678type LaptopStore interface { // ... FindByID(id string) (*pb.Laptop, error)}func (store *InMemoryLaptopStore) FindByID(id string) (*pb.Laptop, error) { //...} 运行测试 123Running tool: /usr/local/go/bin/go test -timeout 30s -run ^TestClientCreateLaptop$ github.com/xiusl/pcbook/serviceok github.com/xiusl/pcbook/service 0.595s 实现真正的 Server &amp; Client 删除主目录的 main.go 新建 cmd/server 和 cmd/client 目录，在两个目录下创建 main.go 12345- cmd/ - server/ - main.go - client/ - main.go 修改 Makefile 1234server: go run cmd/server/main.goclient: go run cmd/client/main.go 完善 cmd/server/main.go 1234567891011121314151617181920func main() { port := flag.String(&quot;port&quot;, &quot;&quot;, &quot;server port&quot;) flag.Parse() log.Printf(&quot;start server on port: %s&quot;, *port) laptopServer := service.NewLaptopServer(service.NewInMemoryLaptopStore()) grpcServer := grpc.NewServer() pb.RegisterLaptopServicesServer(grpcServer, laptopServer) address := fmt.Sprintf(&quot;0.0.0.0:%s&quot;, *port) listener, err := net.Listen(&quot;tcp&quot;, address) if err != nil { log.Fatalf(&quot;cannot start server: %v&quot;, err) } err = grpcServer.Serve(listener) if err != nil { log.Fatalf(&quot;cannot start server: %v&quot;, err) }} 完善 cmd/client/main.go 12345678910111213141516171819202122232425262728293031func main() { addr := flag.String(&quot;addr&quot;, &quot;&quot;, &quot;the server address&quot;) flag.Parse() log.Printf(&quot;dial server: %s&quot;, *addr) conn, err := grpc.Dial(*addr, grpc.WithInsecure()) if err != nil { log.Fatalf(&quot;cannot dial server: %v&quot;, err) } laptopClient := pb.NewLaptopServicesClient(conn) laptop := sample.NewLaptop() req := &amp;pb.CreateLaptopRequest{ Laptop: laptop, } res, err := laptopClient.CreateLaptop(context.Background(), req) if err != nil { st, ok := status.FromError(err) if ok &amp;&amp; st.Code() == codes.AlreadyExists { log.Println(&quot;laptop already exists.&quot;) } else { log.Printf(&quot;laptop create error: %v&quot;, err) } return } log.Printf(&quot;created laptop success, id: %v&quot;, res.Id)} 更新 Makefile 1234server: go run cmd/server/main.go -port=8080client: go run cmd/client/main.go -addr=&quot;0.0.0.0:8080&quot; 运行服务 123$ make server&gt; go run cmd/server/main.go -port=8080&gt; 2021/06/18 23:03:19 start server on port: 8080 运行客户端 1234567$ make client&gt; go run cmd/client/main.go -addr=&quot;0.0.0.:8080&quot;&gt; 2021/06/18 23:13:26 dial server: 0.0.0.0:8080&gt; 2021/06/18 23:13:26 created laptop success, id: d53003bc-0118-4e91-93d8-e7d04c9b7a75// 服务端日志&gt; 2021/06/18 23:13:26 receive a create-laptop request with id:d53003bc-0118-4e91-93d8-e7d04c9b7a75. 修改客户端代码，验证 laptop exist 12345678laptop := sample.NewLaptop()laptop.Id = &quot;d53003bc-0118-4e91-93d8-e7d04c9b7a75&quot;// 运行$ make client&gt; go run cmd/client/main.go -addr=&quot;0.0.0.0:8080&quot;&gt; 2021/06/18 23:14:00 dial server: 0.0.0.0:8080&gt; 2021/06/18 23:14:00 laptop already exists. 修改客户端代码，验证 valid laptop id 12345678laptop := sample.NewLaptop()laptop.Id = &quot;invalid-id&quot;// 运行￥ make client&gt; go run cmd/client/main.go -addr=&quot;0.0.0.0:8080&quot;&gt; 2021/06/18 23:14:10 dial server: 0.0.0.0:8080&gt; 2021/06/18 23:14:10 laptop create error: rpc error: code = InvalidArgument desc = laptap ID is not a valid UUID: invalid UUID length: 10 gRPC 超时和取消 修改 cmd/client/main.go ，对上下文增加超时时间 12345678910func main() { // ... // 1 秒后将超时退出 ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() res, err := laptopClient.CreateLaptop(ctx, req) // ...} 为对超时进行测试，修改 service/laptop_server.go ，增加耗时操作 123456789// service/laptop_server.gofunc (server *LaptopServer) CreateLaptop(ctx context.Context, req *pb.CreateLaptopRequest) (*pb.CreateLaptopResponse, error) { // ... // 新增此行代码测试 time.Sleep(3 * time.Second) err := server.Store.Save(laptop)} 再次运行 server 和 client，发现在客户端超时退出后，相应数据还是写入到了内存中，这是不应该的 12345678910&gt; make server$ 2021/06/19 00:10:41 start server on port: 8080$ 2021/06/19 00:10:43 receive a create-laptop request with id:7154eb98-2459-495e-911d-9e70034094a2.$ 2021/06/19 00:10:46 store save success 7154eb98-2459-495e-911d-9e70034094a2.-----&gt; make client$ 2021/06/19 00:10:43 dial server: 0.0.0.0:8080$ 2021/06/19 00:10:44 laptop create error: rpc error: code = DeadlineExceeded desc = context deadline exceeded 修复超时错误，在实际保存数据时，对上下文进行判断 12345678910111213// service/laptop_server.gofunc (server *LaptopServer) CreateLaptop(ctx context.Context, req *pb.CreateLaptopRequest) (*pb.CreateLaptopResponse, error) { // ... // 新增此行代码测试 time.Sleep(3 * time.Second) if ctx.Err() == context.DeadlineExceeded { log.Print(&quot;deadline is exceeded&quot;) return nil, fmt.Errorf(&quot;deadline is exceeded&quot;) } err := server.Store.Save(laptop)} \u0005再次运行 123456789&gt; make server$ 2021/06/19 00:22:52 receive a create-laptop request with id:f39f76d9-414e-47e3-b38c-efe5a8cea5b5.$ 2021/06/19 00:22:55 deadline is exceeded-----&gt; make client$ 2021/06/19 00:22:52 dial server: 0.0.0.0:8080$ 2021/06/19 00:22:53 laptop create error: rpc error: code = DeadlineExceeded desc = context deadline exceeded 同样，客户端中断执行，在超时前执行 ctrl+c，数据同样被写入，修复问题 123456789101112131415161718// service/laptop_server.gofunc (server *LaptopServer) CreateLaptop(ctx context.Context, req *pb.CreateLaptopRequest) (*pb.CreateLaptopResponse, error) { // ... // 新增此行代码测试 time.Sleep(3 * time.Second) if ctx.Err() == context.Canceled { log.Print(&quot;context is canceled&quot;) return nil, fmt.Errorf(&quot;context is canceled&quot;) } if ctx.Err() == context.DeadlineExceeded { log.Print(&quot;deadline is exceeded&quot;) return nil, fmt.Errorf(&quot;deadline is exceeded&quot;) } err := server.Store.Save(laptop)} –本节结束–","link":"/2021/06/23/go-rpc-01/"},{"title":"iOS 分发 Ad Hoc 应用","text":"公司内部测试 iOS App，之前一直用蒲公英分发，但现在各种平台都要重新认证，自己写一个网页简单分发下 打包好的 App，导出 Ad Hoc 的安装包 编写需要的 plist 文件，差不多下面这个样子 install.plist 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://image.sleen.top/ipa/like.ipa&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.xiusl.like&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.1.2&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;releaseNotes&lt;/key&gt; &lt;string&gt;测试&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;哩嗑&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 再写一个简单的网页 index.html 123456789101112131415&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;title&gt;哩嗑 App&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;font-size:20px;text-align:center;margin-top:100px;&quot;&gt; &lt;a title=&quot;iPhone&quot; href=&quot;itms-services://?action=download-manifest&amp;url=https://image.sleen.top/ipa/install.plist&quot;&gt;哩嗑内测下载&lt;/a&gt; &lt;p style=&quot;font-size:14px;color:#999;&quot;&gt;Note: 内测包安装的设备需要在 Apple Developer 中注册&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后把 install.plist，like.ipa，index.html，上传到测试人员可以访问的地方，这里直接放在了七牛对象存储里，访问 index.html 就能安装喽。","link":"/2020/09/30/iOS-AdHoc-distribute/"},{"title":"iOS 中的 UITest","text":"在 iOS 开发中使用 UITest 对各种点击进行测试，避免上线后出现低级 bug。 在创建项目的时候可以勾选 Include UI Tests 初始化，或者在项目的 Targets 中新增 UITesting Bundle 项目中会出现相应的文件夹 xxUITests，和一个临时的代码文件 xxUITests.m 123456789101112131415161718192021222324#import &lt;XCTest/XCTest.h&gt;@interface XXUITests : XCTestCase@end@implementation XXUITests- (void)setUp { // 在一个测试失败后不再继续 self.continueAfterFailure = NO; // 创建 XCUIApplication 实例，并启动 // 测试必须要确保在每个测试前启动它 [[[XCUIApplication alloc] init] launch];}- (void)tearDown { }- (void)testExample { // 测试代码}@end UITest 是基于下面三个类的实现 123XCUIApplicationXCUIElementXCUIElementQuery 可以使用录制的方式来进行测试将鼠标定位 testExample 的代码块中，点击下面的红色录制按钮，应用会重启，进行操作后会自动生成测试代码 UITest 的基本原则 查找到对应元素（XCUIElementQuery） 明确元素的预期行为 点击元素触发响应 确认预期行为和响应结果是否匹配（assertion） 查找元素 UI对象会有四个属性，不同控件会有不同的默认值，可以在项目中自定义， accessibilityTitle accessibilityPlaceholderValue accessibilityLabel accessibilityValue","link":"/2019/10/18/ios-uitest/"},{"title":"UITableView 中使用 IQKeyboardManager","text":"项目中的表单需要在第一次进入的时候自动弹出键盘，使用 IQKeyboardManager 来调整输入框的时候，键盘收起后 tableView 底部多出一部分。 目前觉得主要的问题是，在 tableView:cellForRowAtIndexPath: 方法中，调用 textField 的 becomeFirstResponder 时，tableView 的 contentOfSize 还没有确定，所以调整 view 的偏移量存在误差。 目前的解决办法是在控制器 viewDidAppear: 方法中来弹出键盘 1234567- (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; if (self.textField &amp;&amp; self.firstEnter) { self.firstEnter = NO; [self.textField becomeFirstResponder]; }}","link":"/2019/03/01/iqkeyboard-tableview/"},{"title":"my-ios-day1","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ #day01 iOS简单路线 UI基础与进阶 网络和多线程 简单项目开发 实用技术 h5跨平台 Swift学习 UIView简单介绍 一般在屏幕上看到的都是UIView，可以把它看做控件或视图 控件包含一些共同的属性，他们都在UIView中定义 尺寸 位置 背景颜色 所有控件的父控件都是UIView 在开发中，我们也会将一些共同的属性抽取到一个父类中 苹果就将控件的一些共同属性抽取在UIView类中 常见属性1234@property(nonatomic,readonly) UIView *superview; // 获得自己的父控件对象@property(nonatomic,readonly,copy) NSArray *subviews; // 获得自己的所有子控件对象@property(nonatomic) NSInteger tag; // 控件的ID(标识)，父控件可以通过tag来找到对应的子控件@property(nonatomic) CGAffineTransform transform; // 控件的形变属性(可以设置旋转角度、比例缩放、平移等属性) 常见方法123- (void)addSubview:(UIView *)view; // 添加一个子控件view- (void)removeFromSuperview; // 将自己从父控件中移除- (UIView *)viewWithTag:(NSInteger)tag; // 根据一个tag标识找出对应的控件（一般都是子控件） 关于尺寸123456// 控件矩形框在父控件中的位置和尺寸(以父控件的左上角为坐标原点)@property(nonatomic) CGRect frame;// 控件矩形框的位置和尺寸(以自己左上角为坐标原点，所以bounds的x、y一般为0)@property(nonatomic) CGRect bounds;// 控件中点的位置(以父控件的左上角为坐标原点)@property(nonatomic) CGPoint center; ##加法计算器","link":"/2016/09/01/my-ios-day1/"},{"title":"my-ios-day10","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 10多控制器管理（一） 项目中常见文件 UIApplication 程序启动原理 UIWindow 加载控制器 常见文件 系统框架及LaunchScreen Xcode5，框架是苹果事先导入进去的，在项目栏中就会看见导入的框架，使用image.xcassets中的LaunchScreen文件 Xcode6，会自动导入一些常用框架，不会看到自动导入的框架，使用LaunchScreen.xib文件 Xcode7，会自动导入一些常用框架，不会看到自动导入的框架，使用LaunchScreen.storyboard文件 新版本中，依旧通过更改项目的General的Launch Screen File配置来使用Assets.xcassets中的LaunchScreen文件 PCH文件 一般与项目名相同，新版本不会自动添加 添加过程 新建一个项目名.pch文件 在Build Setting中查找perfix，找到Precomplie prefix Header设置为 YES 设置prefix Header为pch文件的完整工程路径，项目名/项目名.pch 只要在pch文件中定义的东西，就会被整个应用程序共享 是一个预编译文件，系统提前去编译，完成一些配置 主要用途 存放一些常用的宏，屏幕、版本… 存放公用的头文件，系统分类的头文件 自定义NSLog，实现部署不打印 注意 问题：pch会把当中的所有内容导入到工程中的所有文件中，当工程中存在C语言文件时，就会产生错误 解决：每一个OC文件都会定义一个__OBJC__宏，判断文件是否有这个宏，就可以判断文件类型 UIApplication UIApplication简介 UIApplication对象是一个应用程序的象征，系统为我们创建，是一个单例对象，一个应用程序启动后就是一个UIApplication对象，可以通过[UIApplication sharedApplication]获得这个对象 应用UIApplication对象可以完成一些应用级别的操作 设置应用程序右上角的红色提醒数字 设置联网指示器的可见性 设置应用程序的状态栏 完成应用之间的跳转 UIApplication功能 提醒数字12345678// 获取UIApplication对象UIApplication *app = [UIApplication sharedApplication];// 在设置之前，要注册⼀个通知，从ios8之后，都要先注册一个通知对象，才能够接收到提醒UIUserNotificationSettings *notice = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge categories:nil];// 注册通知对象[app registerUserNotificationSettings:notice];// 设置提醒数字app.applicationIconBadgeNumber = 10; 设置联网状态1app.networkActivityIndicatorVisible = YES; 设置状态栏 状态栏默认是交个控制器管理的12345678// 重写控制器的方法，设置显示样式-(UIStatusBarStyle)preferredStatusBarStyle {return UIStatusBarStyleLightContent;}// 是否隐藏状态栏，YES--显示，NO--隐藏-(BOOL)prefersStatusBarHidden {return NO;} 开发中一般都是应用程序来统一管理，在info.plist文件中添加一个Key值，View controller-based status bar appearance设置为 NO，就交给应用程序管理了123456// 获取UIApplicationUIApplication *app = [UIApplication sharedApplication];// 设置状态栏样式.app.statusBarStyle = UIStatusBarStyleLightContent;// 设置状态的隐藏app.statusBarHidden = YES; 跳转网页12345UIApplication *app = [UIApplication sharedApplication];// URL--协议头://域名// 应用程序通过协议头的类型，去打开相应的软件NSURL *url =[NSURL URLWithString:@&quot;http://www.baidu.com&quot;];[app openURL:url]; 打电话发短信1234// 打电话[app openURL:[NSURL URLWithString:@&quot;tel://10086&quot;]];// 发短信[app openURL:[NSURL URLWithString:@&quot;sms://10086&quot;]]; UIApplication代理 所有的移动应用有一个致命的缺点：app容易受到打扰，如来电话，锁屏等会导致app进入后台甚至会被终止 iOS中当app受到干扰的时候会产生一些系统事件，这时UIApplication会通知它的代理对象，来做一些相应的处理 AppDelegate类就是在程序启动创建的一个遵守UIApplicationDelegate的类，在这个类中定义很多方法来处理事件 主要方法123456789101112131415161718192021222324252627#parmark 应⽤程序的⽣生命周期// 应用程序启动完成的时候调⽤- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions: (NSDictionary *)launchOptions {NSLog(@&quot;%s&quot;,__func__);return YES;}// 当我们应用程序即将失去焦点的时候调⽤- (void)applicationWillResignActive:(UIApplication *)application {NSLog(@&quot;%s&quot;,__func__);}// 当我们应⽤程序完全进⼊后台的时候调⽤- (void)applicationDidEnterBackground:(UIApplication *)application{NSLog(@&quot;%s&quot;,__func__);}// 当我们应用程序即将进⼊前台的时候调⽤- (void)applicationWillEnterForeground:(UIApplication *)application {NSLog(@&quot;%s&quot;,__func__);}// 当我们应⽤程序完全获取焦点的时候调⽤// 只有当一个应⽤程序完全获取到焦点,才能与用户交互.- (void)applicationDidBecomeActive:(UIApplication *)application {NSLog(@&quot;%s&quot;,__func__);}// 当我们应用程序即将关闭的时候调⽤- (void)applicationWillTerminate:(UIApplication *)application {NSLog(@&quot;%s&quot;,__func__);} 应用程序启动原理 程序启动时，依旧最先执行main函数12345678int main(int argc, char * argv[]) {@autoreleasepool {// 第三个参数:UIApplication类名或者⼦类的名称 nil == @&quot;UIApplication&quot;// 第四个参数:UIApplication的代理的代理名称// NSStringFromClass:把类名转化字符串， NSStringFromClass好处:1.有提示功能 2.避免输入错误return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));}} 程序启动流程 执行main函数 执行UIApplicationMain函数 创建UIApplication对象，设置UIApplication对象的代理 开启一个主循环，保证应用程序不会退出 加载info.plist配置文件，判断文件中的Main storyboard file base name有没有指定storyboard文件，若果有指定就去加载文件 UIWindow UIWindow简介 UIWindow是一个特殊的UIView，通常一个app中至少有一个UIWindow，一个iOS程序之所以可以显示到屏幕上，就是靠UIWindow iOS启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View，在将控制器的View添加到UIWindow上 UIWindow创建 加载info.plist文件后，如果存在main就会加载storyboard 创建一个窗口 加载main.storyboard，初始化一个控制器 把初始化的控制器设为窗口的根控制器，显示到屏幕上 如果没有指定main这个时候就需要在程序加载完毕后手动创建UIWindow12345678910111213// 应用程序启动完成的时候调⽤- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions: (NSDictionary *)launchOptions {// 创建窗口self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];// 创建控制器UIViewController *Vc = [[UIViewController alloc] init];Vc.view.backgroundColor = [UIColor redColor];// 设置根控制器self.window.rooViewController = Vc;// 显示窗口[self.window makeKeyAndVisiable];return YES;} makeKeyAndVisible的底层实现 让窗⼝变为显示状态1self.window.hidden = NO; 把根控制器的View添加到窗口上1[self.window addSubView:rootVC.view]; 把当前窗口设置成应用程序的主窗⼝application.keyWindow获得应用程序的主窗⼝在程序中，状态栏和键盘都是窗口self.window.windowLevel = UIWindowLevelNormal层级关系UIWindowLevelNormal &lt; UIWindowLevelStatusBar &lt; UIWindowLevelAlert 加载控制器 storyboard 过程1234567891011// 创建窗口self.window = [[UIWindow alloc] inihFrame:[UIScreen mainScreen].bounds];// 加载控制器// 指定storyboardUIStoryboard *storyboard =[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];// 加载箭头指向的VcUIViewController *Vc = [storyboard instantiateInitialViewController];// 设置根控制器self.window.rooViewController = Vc;// 显示窗口[self.window makeKeyAndVisiable]; 加载控制器的两种方式123456// 指定storyboardUIStoryboard *storyboard =[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];// 加载箭头指向的VcUIViewController *Vc = [storyboard instantiateInitialViewController];// 加载指定标识的控制器.UIViewController *Vc = [storyBoard instantiateViewControllerWithIdentifier:@&quot;VCStoryBoardID&quot;]; xib12345678// 创建窗⼝self.window = [[UIWindow alloc] initWithFrame:[UIScreen nScreen].bounds];// 从XIB当中加载控制器.MyViewController *Vc = [[MyViewController alloc] tWithNibName:@&quot;VC&quot; bundle:nil];// 设置根控制器self.window.rootViewController = Vc;// 显⽰示窗⼝[self.window makeKeyAndVisible];","link":"/2016/09/01/my-ios-day10/"},{"title":"my-ios-day11","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 11多控制器管理（二） UINavigationController 通讯录简例 数据存储 UITabBarController UINavigationController 使用步骤 初始化UINavigationController 设置UIWindow的rootViewController为UINavigationController 根据具体情况，通过push方法添加子控制器 子控制器 UINavigationController以栈的形式保存子控制器 12@property(nonatomic,copy) NSArray *viewControllers;@property(nonatomic,readonly) NSArray *childViewControllers; 使用push方法将子控制器入栈 1- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated; 使用pop方法移除控制器 123456// 将栈顶的控制器移除- (UIViewController *)popViewControllerAnimated:(BOOL)animated;// 回到指定的子控制器- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;// 回到根控制器（栈底控制器）- (NSArray *)popToRootViewControllerAnimated:(BOOL)animated; navigationItem 导航条的内容由navigationItem决定 常用属性 12345678910// 左上角的返回按钮@property(nonatomic, retain) UIBarButtonItem *backBarButtonItem;// 中间的标题视图@property(nonatomic, retain) UIView *titleView;// 中间的标题文字@property(nonatomic, copy) NSString *title;// 左上角的视图@property(nonatomic, retain) UIBarButtonItem *leftBarButtonItem;// 右上角的视图@property(nonatomic, retain) UIBarButtonItem *rightBarButtonItem; segue storyboard上的每一条控制器之间的线都是一个UIStoryboardSegue对象 属性 123456// 唯一标识@property (nonatomic, readonly) NSString *identifier;// 来源控制器@property (nonatomic, readonly) id sourceViewController;// 目标控制器@property (nonatomic, readonly) id destinationViewController; 类型 手动型：需要通过代码手动执行segue，才能完成跳转 123// 需要为segue绑定一个唯一标识// segue必须由来源控制器来执行，也就是说，这个perform方法必须由来源控制器来调用- [self performSegueWithIdentifier:@&quot;login2contacts&quot; sender:nil]; 自动型：点击某个控件，自动自行segue，自动跳转 performSegueWithIdentifier:sender:执行过程 根据identifier在storyboard中找到对应的线，新建UIStoryboardSegue对象 设置segue对象的sourceViewControl 新建并设置segue对象的destinationViewController 调用sourceViewController的prepareForSegue: sender:方法，做一些跳转前的准备并传入创建好的segue 调用segue的perform方法，开始执行界面跳转操作 控制器间的数据传递 顺传 数据方向：sourceViewcontroller-&gt;destinationViewController 传递方式：在源控制器sourceViewcontroller的prepareForSegue:sender:方法中根据segue参数取得destinationViewController, 也就是目标控制器，直接给控制器赋值 逆传 数据方向：destinationViewController-&gt;sourceViewcontroller 传递方式：让源控制器sourceViewcontroller成为目标控制器destinationViewController的代理，在目标控制器destinationViewController中调用源控制器sourceViewcontroller的代理方法，通过代理方法的参数传递数据给源控制器 ####通讯录 结构分析 登录界面 登录按钮只有文本框都有文字才能点击 自动登录开关和记住密码开关的协调 文本框占位符，提示输入信息 密码文本框是暗文 文本框输入文字后会有清除按钮 点击登录会判断账号和密码是否正确，只有正确才跳转，提示用户正在登录，模拟网络延迟 联系人列表界面 联系人列表导航条标题跟账号有关系，控制器之间传值 注销按钮回到登录界面 添加按钮，进入联系人编辑界面 添加联系人界面 默认弹出姓名的文本框，不需要用户点击文本框弹出键盘 添加按钮，只有文本框都有文字才能点击 点击添加后，回到联系人界面，并把数据显示到联系人列表 编辑联系人界面 点击联系人界面的cell，进入编辑界面 默认保存按钮是隐藏的，默认文本框不能交互，是查看联系人 点击编辑按钮的时候，文本框才会允许交互，并且保存按钮默认不能点击 默认弹出电话文本框，一般修改联系人都是修改电话 编辑状态，点击取消按钮，恢复文本框数据回到查看联系人 编辑状态，点击保存，提示用户保存，并显示到联系人界面 界面较少且固定，采用storyboard开发，使用导航控制器 具体代码在 07-通讯录 数据存储 plist存储 存数据 数据存储是保存在手机里面，保存到应用的沙盒中 plist文件一般存储的都是字典和数组，直接写成plist文件，保存到沙盒中 每个应用在手机中都有一个文件夹，通过下面的方法获取当前应用的手机里安装的路径1NSString *homeDir = NSHomeDirectory(); 123456789101112131415161718/*** 在某个范围内搜索文件夹的路径* 方法会得到一个数组（可能会有多个路径）* directory：获取哪个文件夹* domainMask：在哪个路径下搜索* expandTilde：是否展开路径*/NSArray *arr = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserdomainMask, YES);// 在这里我们搜索的是Cache目录，结果只有一个NSString *cachePath = arr[0];// 拼接文件路径NSString *filePathName = [cachePath stringByAppendingPathComponent:@&quot;agePlist.plist&quot;];// 保存字典NSDictionary *dict = @{@&quot;age&quot; : @18,@&quot;name&quot; : @&quot;gaowei&quot;};[dict writeToFile:filePathName atomically:YES];// 保存数组NSArray *dataArray = @[@56,@&quot;asdfa&quot;];[dataArray writeToFile:filePathName atomically:YES]; 读取文件 与写基本相同，都是通过路径完成1234567891011// 同样搜索路径NSArray *array = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUs erDomainMask, YES);// 拿到路径NSString *cachePath = array[0];// 拼接⽂件路径NSString *filePathName = [cachePath stri ngByAppendingPathComponent:@&quot;agePlist.plist&quot;];// 从⽂件当中读取字典NSDictionary *dict = [NSDictionary dict ionaryWithContentsOfFile:filePathName];// 从⽂件当中读取数组NSArray *dataArray = [NSArray arrayWithContentsOfFile:filePathName];NSLog(@&quot;%@&quot;,dataArray); 偏好设置 NSUserDefaults 写数据12345678// 默认在目录下生成一个字典，并以plist文件的方式储存// 不用关心文件名，快速进行键值对存储NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];[defautls setObject:@&quot;sleen&quot; forKey:@&quot;name&quot;];[defautls setBool:YES forKey:@&quot;isBool&quot;];[defautls setInteger:5 forKey:@&quot;num&quot;];//同步，⽴即写⼊文件.[defautls synchronize]; 读数据12345678// 存的时候用什么key存的, 读的时候就要用什么key值取// 存的时候用什么类型,取的时候也要⽤什么类型.NSString *str = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;name&quot;];BOOL isBool =[[NSUserDefaultsstandardUserDefaults]boolForKey:@&quot;isBool&quot;];NSInteger num = [[NSUserDefaults standardUserDefaults]integerForKey:@&quot;num&quot;];NSLog(@&quot;name =%@-isBool=%d-num=%ld&quot;,str,isBool,num); 归档 归档一般都是保存自定义对象的时候，plist文件不能完成需求，如果一个字典中保存有自定义对象，如果要把字典写到文件中，是不会写成plist文件的 保存数据12345678910// 自定义的对象SLPerson *person = [[SLPerson alloc] init];person.name = @&quot;sleen&quot;;person.age = 18;// 获取沙盒临时目录NSString *tempPath = NSTemporaryDirectory();NSString *filePath = [tempPath stringByAppendingPathComponent:@&quot;person.data&quot;];// archiveRootObject这个⽅法底层会去调用保存对象的encodeWithCoder⽅法，去询问要保存这个对象的哪些属性[NSKeyedArchiver archiveRootObject:person toFile:filePath]; 读取数据1234567// 获取沙盒临时目录NSString *tempPath = NSTemporaryDirectory();NSString *filePath = [tempPath stringByAppendingPathComponent:@&quot;persion.data&quot;];// NSKeyedUnarchiver会调用initWithCoder这个方法，来让你告诉它去获取这个对象的哪些属性Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];NSLog(@&quot;name=%@---age=%d&quot;,person.name,person.age); 在自定义的对象中，要遵守NSCoding协议123456789101112131415161718192021// SLPerson.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject &lt;NSCoding&gt;@property (nonatomic, strong) NSString *name;@property (nonatomic, assign) int age;@end// SLPerson.m#import &quot;SLPerson.h&quot;@implementation SLPerson- (void)encodeWithCoder:(NSCoder *)encode {[encode encodeObject:self.name forKey:@&quot;name&quot;];[encode encodeInt32:self.age forKey:@&quot;age&quot;];}- (instancetype)initWithCoder:(NSCoder *)decoder {if (self = [super init]) {self.age = [decoder decodeInt32ForKey:@&quot;age&quot;];self.name = [decoder decodeObjectForKey:@&quot;name&quot;];}return self;}@end UITabBarController 基本使用 UITabBarController与UINavigationController类似，管理多个控制器，在底部有一个导航条UITabBar（高度49） 添加控制器12345// 两种方法// 添加单个⼦子控制器- (void)addChildViewController:(UIViewController *)childController// 设置⼦子控制器数组@property(nonatomic,copy) NSArray *viewControllers; 简单应用12345678910111213141516171819202122// 设置窗口self.window = [[UIwindow alloc] init];// 初始化tabbarUITabBarController *tabbar = [[UITabBarController alloc] init];// 为tabbar添加子控制器UIViewController *vc1 = [[UIViewController alloc] init];vc1.view.backgroundColor = [UIColor redColor];// 设置标题vc1.tabBarItem.title = @&quot;标题1&quot;;// 设置提醒数字vc1.tabBarItem.badgeValue = @&quot;10&quot;;[tabBar addChildViewController:vc1];UIViewController *vc2 = [[UIViewController alloc] init];vc2.view.backgroundColor = [UIColor yellowColor];[tabBar addChildViewController:vc2];UIViewController *vc3 = [[UIViewController alloc] init];vc3.view.backgroundColor = [UIColor blueColor];[tabBar addChildViewController:vc3];// 设置窗口根控制器self.window.rootViewController = tabbar;// 显⽰示窗⼝口[self.window makeKeyAndVisible]; 管理原则 TabBarController默认做法是把它的第⼀个子控制器的View添加到TabBarController存放子控制器的View当中 如果TabBarController有N个⼦控制器，那么TabBar内部就会有N个按钮 点击每一个按钮, 它会先把当前控制器的View从TabBarController存放⼦控件View的View当中移除(只是移除view，子控制器还在数组当中，没有被移除) 再把当前选中按钮对应子控制器的View添加到TabBarController存放⼦控件View中 主流框架搭建 窗口的根控制器为UITabBarController，再将UINavigationController添加到UITabBarController中","link":"/2016/09/01/my-ios-day11/"},{"title":"my-ios-day12","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 12事件处理 简介 UIView的触摸事件 最合适的View 事件响应 手势识别 事件处理 iOS中常用的事件分为三种 触摸事件 加速计事件 远程控制事件 响应者对象 继承自UIResponder 的对象称为响应者 UIApplication、UIViewController、UIView等，他们都是响应者对象，能够接收和处理事件 UIResponder类 触摸事件1234- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 加速计事件123- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件1- (void)remoteControlReceivedWithEvent:(UIEvent *)event; 事件的产生和传递 产生当发生一个触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理 传递主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件触摸事件的传递是从父控件传递到子控件的如果一个父控件不能接收事件，那么它里面的子控件也不能够接收事件 不能接受事件的情况 不接收用户交互时不能够处理事件userInteractionEnabled = NO 当一个控件隐藏的时候不能够接收事件hidden = YES 当一个控件为透明白时候也不能够接收事件alpha = 0· 注意UIImageViewd的userInteractionEnabled默认为NO，因此UIImageView和它的子控件默认都不能接收事件 UIView的触摸事件 要监听UIView的触摸事件，要使用自定义的view并实现UIResponder中的相应方法 主要事件123456// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法.- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指在view上移动时，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法，也就是说这个方法会调用很多次）- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event 参数说明12345678910touches：touches中存放的都是UITouch对象，是一个NSSet集合UITouch对象是用来保存手指相关联的信息，位置、时间、阶段等信息每一个手指对应一个UITouch对象，这个对象是系统自动为我们创建的，当手指移动时，系统会更新同一个UITouch对象，使它一直保存该手指的信息通过获取UITouch属性，我们可以获得触摸产生时所处的窗口，触摸的View，时间，点击的次数等还可以通过UITouch提供的方法获取当前手指所在的点,以及上一个手指所在的点- (CGPoint)locationInView:(UIView *)view;- (CGPoint)previousLocationInView:(UIView *)view;event:每产生一个事件，就会产生一个UIEvent对象，记录事件产生的时刻和类型 触摸过程 触摸开始1- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; 触摸移动1- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; 触摸结束1- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; 触摸取消（可能会经历）1- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 注意一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象 ####最合适的view- 寻找最合适的view1. 先判断自己是否可以接收触摸事件，如果可以进行下一步2. 判断触摸的点是否在自己上3. 如果在自己上，从后往前遍历子控件，子控件重复上述两步4. 如果没有符合条件的子控件，那么它自己就是最合适的view- hitTest方法与pointInside方法- 使用1234567891011121314/*** 寻找最合适的view* point：当前手指所在的点* event：产生的事件* 返回值：最合适的view* 调用：只要一个事件传递给一个控件，就会调用这个控件的hitTest方法*/- (UIView *)hitTest:(CGPoint) withEvent:(UIEvent *)event;/*** 判断point在不在方法的调用者上* point：必须是调用者的坐标系* 调用：hitTest底层会调用*/- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;- 底层实现1. 判断当前能否接收事件12if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01)return nil;2. 判断触摸点在不在当前控件上12if (![self pointInside:point withEvent:event])return nil;3. 从后往前遍历子控件123456789101112int count = (int)self.subviews.count;for (int i = count - 1; i &gt;= 0; i--) {UIView *childView = self.subViews[i];// 转换坐标系CGPoint childPoint = [self convertPoint:point toView:childView];// 判断是否最合适UIView *fitView = [child hitTest:childPoint withEvent:event];// 如果最适合，就直接返回if (fitView) {return fitView;}}4. 自己就是最合适的View1return self;事件响应 响应者链条 是由多个响应者对象连接起来的链条 响应者对象 继承了UIResponder的对象称之为响应者对象，用来处理事件的对象 事件传递 在产生一个事件时，系统会将该事件加入到一个由UIApplication管理的事件队列中 UIApplication会从事件队列中取出最前面的事件，将它传递给先发送事件给应用程序的主窗口 主窗口会调用hitTest方法寻找最适合的视图控件，找到后就会调用视图控件的touches方法来做具体的事情 当调用touches方法，它的默认做法，就会将事件顺着响应者链条往上传递，传递给上一个响应者，接着就会调用上一个响应者的touches方法 上一个响应者 如果当前的View是控制器的View，那么控制器就是上一个响应者 如果当前的View不是控制器的View，那么它的父控件就是上一个响应者 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 如果window对象也不处理，则其将事件或消息传递给UIApplication对象 如果UIApplication也不能处理该事件或消息，则将其丢弃 手势识别 手势识别器 UIGestureRecognizer苹果官方推出的手势识别功能 可以轻松识别用户在某个View上的常见手势 是一个抽象类，定义了所有手势的基本行为，使用其子类就可以处理具体的手势 几种常见手势123456UITapGestureRecognizer // 敲击UIPinchGestureRecognizer // 捏合，用于缩放UIPanGestureRecognizer // 拖拽UISwipeGestureRecognizer // 轻扫UIRotationGestureRecognizer // 旋转UILongPressGestureRecognizer // 长按 手势的使用 点按手势12345678910111213141516// Target：当哪对象要坚听手势// action：手势发生时调用的方法UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];// 手势也可以设置代理tap.delegate = self;// 添加手势[self.imageV addGestureRecognizer:tap];// 手指开始点击时调用- (void)tap {NSLog(@&quot;%s&quot;, __func__);}// 手势代理方法- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {// 获取当前手指所在的点CGPoint curP = [touch locationInView:self.imageV];} 长按手势123456789101112131415161718UILongPressGestureRecognizer *longP = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];// 添加手势[self.imageV addGestureRecognizer:longP];// 当手指长按时调用// 注意，长按手势会调用多次，当开始长按时会调用，当长按松开时会调用，当长按移动时，也会调用// 一般我们都是在长按刚开始时做事情，所以要判断它的状// 这个状态是保存的当前的手势当中 所以要把当前的长按手势传进来，来判断当前手势的状态- (void)longPress:(UILongPressGestureRecognizer *)longP {// 手势的状态是一个枚举UIGestureRecognizerState，可以进入头文件当中查看if (longP.state == UIGestureRecognizerStateBegan) {NSLog(@&quot;开始长按时调用&quot;);}else if (longP.state == UIGestureRecognizerStateChanged) {// 会持续调用NSLog(@&quot;当长按拖动时调用&quot;);}else if (longP.state == UIGestureRecognizerStateEnded) {NSLog(@&quot;当长按松手指松开进调用&quot;);}} 轻扫手势123456UISwipeGestureRecognizer *swipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];// 注意：轻扫手势默认轻扫的方向是往右轻扫，可以去手动修改轻扫的方向// 一个手势只能对象一个方向，想要支持多个方向的轻扫，要添加多个轻扫手势swipe.direction = UISwipeGestureRecognizerDirectionLeft;// 添加手势[self.imageV addGestureRecognizer:swipe]; 平移手势123456789101112131415UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];// 添加手势[self.imageV addGestureRecognizer:pan];// 实现手势方法// 手指在屏幕上移动进调用- (void)pan:(UIPanGestureRecognizer *)pan{// 获取当前手指移动的偏移量CGPoint transP = [pan translationInView:self.imageV];NSLog(@&quot;%@&quot;, NSStringFromCGPoint(transP));// Make它会清空上一次的形变self.imageV.transform = CGAffineTransformMakeTranslation(transP.x, transP.y);self.imageV.transform = CGAffineTransformTranslate(self.imageV.transform, transP.x, transP.y);// 复位，相对于上一次[pan setTranslation:CGPointZero inView:self.imageV];} 旋转手势123456789101112131415// 添加旋转手势UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotation:)];// 设置代理，设置代理的目的就让它能够同时支持旋转跟缩放rotation.delegate = self;// 添加手势[self.imageV addGestureRecognizer:rotation];// 当旋转时调用- (void)rotation:(UIRotationGestureRecognizer *)rotation {// 旋转也是相对于上一次self.imageV.transform = CGAffineTransformRotate(self.imageV.transform, rotation.rotation);// 设置代理,设置代理的目的就让它能够同时支持旋转跟缩放rotation.delegate = self;// 也要做复位操作rotation.rotation = 0;} 缩放手势1234567891011// 添加缩放手势UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinch:)];// 添加手势[self.imageV addGestureRecognizer:pinch];// 缩放手势时调用- (void)pinch:(UIPinchGestureRecognizer *)pinch {// 平移也是相对于上一次self.imageV.transform = CGAffineTransformScale(self.imageV.transform, pinch.scale, pinch.scale);// 复位pinch.scale = 1;}","link":"/2016/09/01/my-ios-day12/"},{"title":"my-ios-day13","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 13Quartz2D 简介 基本线条绘制 小实例 应用 简介 Quartz2D 一个同时支持Mac和iOS的二维绘图引擎 画基本线条、绘制文字、图片、截图、自定义UIView 当所需控件样式及其复杂时，可以将控件内部的结构绘制出来，就是自定义控件 图形上下文 用来保存用户绘制的内容状态，并决定绘制到哪里 用户会把需要绘制的内容保存到图像上下文，根据选择的图形上下文，显示到不同的地方，即输出的目标不同 常见上下文Bitmap Graphics Context 位图上下文PDF Graphics Context PDF上下文Window Graphics Context 窗口上下文Layer Graphics Context 图层上下文Printer Graphics Context 打印上下文 自定义UIView 创建一个继承UIView的SLView 实现DrawRect方法 在DrawRect方法中取得与View相关的上下文 绘制路径 把描述好的路径保存到上下文中 把上下文中的内容渲染到View上 基本线条绘制 DrawRect方法 在这给方法中完成绘图操作，只有这个方法才能拿到与View关联的上下文 当View显示时，系统自动调用 画直线 基本过程123456789101112// 获取与view关联的上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 绘制路径UIBezierPath *path = [UIBeizerPath beizerPath];// 设置起点[path moveToPoint:CGPointMake(50, 50)];// 添加一根线到一个点[path addLineToPoint:CGPointMake(200, 100)];// 把路径添加到上下文CGContextAddPath(ctx, path.CGPath);// 在view上渲染CGContextStrokePath(ctx); 再添加一条线 第一种：重新设置起点，添加一根线到一个点，一个UIBezierPath路径可以有多条线 第二种：直接在原来的基础上，把上一条线的终点作为起点，直接addLineToPoint: 线的属性设置这个属性，就是修改图形上下文的状态设置线宽：CGContextSetLineWidth(ctx, 20);设置线段的连接样式：CGContextSetLineJoin(ctx, kCGLineJoinRound);添加顶角样式：CGContextSetLineCap(ctx, kCGLineCapRound);设置线的颜色：[[UIColor redColor] setStroke]; 画曲线 画曲线方法比较特殊，需要一个控制点来决定曲线的弯曲程度1234// 先设置一个曲线的起点[path moveToPoint:CGPointMake(30, 125)];// 再添加到个点到曲线的终点，同时还须要一个controlPoint(控制点决定曲线弯曲)[path addQuadCurveToPoint:CGPointMake(200, 120) controlPoint:CGPointMake(120, 40)]; 画矩形（圆角） 画矩形直接利用UIBezierPath给我们封装好的路径方法123// (x, y)点决定了矩形左上角的点在哪个位置// (width, height)是矩形的宽度高度bezierPathWithOvalInRect:CGRectMake(x, y, width, height) 圆角矩形的画法多了一个参数cornerRadius123// cornerRadius它是矩形的圆角半径.// 通过圆角矩形可以画一个圆，当矩形是正方形的时候，把圆角半径设为宽度的一半，就是一个圆bezierPathWithRoundedRect:CGRectMake(10, 100, 50, 50) cornerRadius:10 画椭圆（圆） 方法123// 前两个参数分别代码圆的圆心，后面两个参数分别代表圆的宽度与高度// 宽高都相等时，画的是一个正圆，不相等时画的是一个椭圆bezierPathWithOvalInRect:CGRectMake(10, 100, 50, 50) 画圆弧 首先要确定圆才能确定圆弧，圆孤就是圆的一部分1234567// center：圆心// radius：圆的半径// startAngle：起始角度// endAngle：终点角度// clockwise：Yes顺时针，No逆时针// 注意：startAngle角度的位置是从圆的最右侧为0度UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(125, 125) radius:100 startAngle:0 endAngle:M_PI * 2 clockwise:YES]; UIKit的封装 [path stroke]方法直接使用 底层：获取上下文，拼接路径，添加路径，渲染 小实例 下载进度条 搭建界面 拖动滑块时，圆弧的大小也改变，进度数字也实时变（显示%需要转义%%） 相关代码12345678910111213141516// 从最上面，按顺时针画，它的起始角度是-90度，结束角度也是-90度// 起始角度-90度，看你下载进度是多少，假如说你下载进度是100，就是1 * 360度CGContextRef ctx = UIGraphicsGetCurrentContext();CGPoint center = CGPointMake(50, 50);CGFloat radius = rect.size.width * 0.5;CGFloat startA = -M_PI_2;CGFloat endA = -M_PI_2 + M_PI * 2 * progress;UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];要获得Progress的值，拖线拿到它的该变量要在值改变的时候就要传进来，并且每次值改变的时候就要去绘制圆弧重写`setProgress:`方法- (void)setProgress:(CGFloat)progress{_progress = progress;// 手动调用drawRect方法，让它重新绘制[self drawRect:self.bounds];} 运行后不绘制 原因：DrawRect方法是不能手动调用，因为在DrawRect方法中需要获取跟View相关联的上下文。系统在调用DrawRect方法时，会自动创建一个跟View相关联的上下文，并且传递给它。自己调用，没有给DrawRect方法传递上下文，所以在DrawRect方法中没有上下文 解决：想要重绘，调用[self setNeedsDisplay]，告诉系统重新绘制View，系统就会自动调用DrawRect方法，这样就可以获得上下文进行绘制 饼状图 方法1234567891011121314151617181920212223242526272829// 获取上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 基本数据CGPoint center = CGPointMake(125, 125);CGFloat radius = 100;CGFloat startA = 0;CGFloat endA = 0;CGFloat angle = 25 / 100.0 * M_PI * 2;endA = startA + angle;// 拼接路经UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];// 添加一条线到圆心[path addLineToPoint:center];// 把路径添加到上下文CGContextAddPath(ctx, path.CGPath);// 把上下文渲染到ViewCGContextFillPath(ctx);// 第二个扇形startA = endA;angle = 25 / 100.0 * M_PI * 2;endA = startA + angle;path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];[path addLineToPoint:center];// 把二个路径添加到上下文CGContextAddPath(ctx, path.CGPath);// 把上下文渲染到ViewCGContextFillPath(ctx);// 添加第二个扇形之后，发现它们的颜色都一样，想要修改它的颜色，在下面再写一个[[UIColor greenColor] set]; 第三个扇形的基本方法与上面基本相同，发现代码重复较多，进行抽取 抽取后123456789101112131415161718192021222324252627// 假设给一组数据NSArray datas = @[@25, @25, @50];CGPoint center = CGPointMake(125, 125);CGFloat radius = 100;CGFloat startA = 0;CGFloat angle = 0;CGFloat endA = 0;for (NSNumber *number in datas) {startA = endA;angle = number.intValue / 100.0 * M_PI * 2;endA = startA + angle;// 描述路径UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];// 添加直线[path addLineToPoint:center];// 随机颜色[[self randomColor] set];// 闭合[path fill];}// 随机返回颜色，开发时可定义为宏- (UIColor *)randomColor {CGFloat r = arc4random_uniform(256)/ 255.0;CGFloat g = arc4random_uniform(256)/ 255.0;CGFloat b = arc4random_uniform(256)/ 255.0;return [UIColor colorWithRed:r green:g blue:b alpha:1];} UIKit绘图 绘制文字12345// 先创建好要画的文字NSString *str = @&quot;Sleen&quot;;// drawAtPoint：要画到哪个位置// withAttributes：文本的样式.[str drawAtPoint:CGPointZero withAttributes:nil]; 属性设置12345678910111213141516// 通过绘制方法的最后一个属性withAttributes来设置文字属性// 创建一个可变的字典,设置key,valueNSMutableDictionary *dict = [NSMueDictionary dictionary];// 字体dict[NSFontAttributeName] = [UIFont sys tOfSize:50];// 颜色dict[NSForegroundColorAttributeName] = [UIColor red ;// 设置边框颜色dict[NSStrokeColorAttributeName] = [UIColor redCo;dict[NSStrokeWidthAttributeName] = @1;// 阴影NSShadow *shadow = [[NSShadow alloc] init];shadow.shadowOffset = CGSizeMake(10, 10);shadow.shadowColor = [UIColor greenColor];shadow.shadowBlurRadius = 3;dict[NSShadowAttributeName] = shadow; 绘制图片 绘制图片同样开始要先把图片素材导入 AtPoint：参数说明图片要绘制到哪个位置 通过调用UIKit的方法drawAtPoint:CGPointZero方法进行绘制 两个方法 文字 drawAtPoint: 不能换行 drawInRect: 能够换行 图片 drawAtPoint: 按照图片尺寸绘制 drawInRect: 图片尺寸与Rect的尺寸一样 平铺图片1[image drawAsPatternInRect:rect]; 快速矩形1UIRectFill(rect); 裁剪12// 这个方法必须要设置好裁剪区域，才能有裁剪效果UIRectClip(CGRectMake(0, 0, 50, 50)); 仿UIImageView 思路 分析系统UIImageView的功能 创建UIImageView对象，设置frame，设置image，添加到view上 创建时就设置image，frame与图片尺寸相同 实现 新建一个UIView，如SLImageView 给SLImageView添加一个UIImage属性 在DrawRect方法中绘制图片到view上 重写UIImage的set方法，实现切换图片 提供- (instancetype)initWithImage:(UIImage *)image;方法 代码1234567891011121314- (instancetype)initWithImage:(UIImage *)image {if (self = [super init]) {self.frame = CGRectMake(0, 0, image.size.width, image.size.height);_image = image;}return self;}- (void)setImage:(UIImage *)image {_image = image;[self setNeedsDisplay];}- (void)drawRect:(CGRect)rect {[_image drawInRect:rect];} 雪花 思路 首先绘制一个雪花 在View加载完毕添加一个定时器 在定时器中调用重绘方法 在重绘方法中不断修改雪花的y值 当y值超过屏幕，就重设为0 定时器 NSTime和CADisplayLink setNeedsDisplay方法底层会调用DrawRect，但是它不是立马就进行重绘，它仅仅是设置了一个重绘标志，等到下一次屏幕刷新的时候才会调用DrawRect方法 NSTime的时间可能和屏幕的刷新时间不匹配，就会产生延迟，造成界面卡顿，CADisplayLink的时间正好与屏幕刷新时间相同 使用CADisplayLink添加定时器123456// target：哪个对象要监听方法// selector：监听的方法名称CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(setNeedsDisplay)];// 想要让CADisplayLink工作，必须得要把它添加到主运行循环// 只要添加到主运行循环，跟模式没有关系[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; 代码12345678910111213- (void)awakeFromNib {CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(setNeedsDisplay)];[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];}- (void)drawRect:(CGRect)rect {if (_snowY &gt; rect.size.height) {_snowY = 0;}UIImage *image = [UIImage imageNamed:@&quot;雪花&quot;];[image drawAtPoint:CGPointMake(0, _snowY)];_snowY += 10;} 水印 用处 标明图片来源（微博） 防止盗图（淘宝） 思路 开启一个和原始图片一样的图片上下文 把原始图片绘制到上下文 再把要添加的水印（文字，logo）等绘制到图片上下文 最后从上下文中取出一张图片 关闭上下文 主要代码123456789// 开启一个图片上下文?// size：开启多大的上文// opaque：不透明度// scale：缩放上下文.UIGraphicsBeginImageContextWithOptions(image.size, YES, 0);// 从图片上下文当中生成一张图片UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();// 关闭上下文UIGraphicsEndImageContext(); 圆形头像（裁剪） 思路 开启一个图片上下文 上下文的大小和原始图片保持一样，以免图片被拉伸缩放 在上下文的上面添加一个圆形裁剪区域，圆形裁剪区域的半径大小和图片的宽度一样大 把要裁剪的图片绘制到图片上下文当中 从上下文当中取出图片 关闭上下文 主要代码1234// 设置圆形路径UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, image.size.width, image.size.width)];// 把一个路径设为裁剪区域[path addClip]; 截屏 思路 将UIView上的东西保存到图片上下文中，生成一张新图片 UIView神的东西是不能直接保存的，需要的是view内部的layer层 调用layer的renderInContext:方法 代码12345678910// 开启一个图片上UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, NO, 0);// 获取当前的上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 把控制器View的内容绘制上下文当中[self.view.layer renderInContext:ctx];// 从上下文当中取出图片UIImage *newImage = UIGraptImageFromCurrentImageContext();// 关闭上下文UIGraphicsEndImageContext(); 图片擦除 思路 两张不同的图片，上面一张，下面一张 添加手势，手指移动擦除图片 确定擦除区域大小和位置 生成新的图片（擦除区域透明），就可以看到后面的图片 代码123456789101112131415161718192021// 确定擦除的范围CGFloat rectWH = 30;// 获取手指的当前点.curPCGPoint curP = [pan locationInView:pan.view];CGFloat x = curP.x - rectWH * 0.5;CGFloat y = curP.y - rectWH * 0.5;CGRect rect = CGRectMake(x, y,rectWH, rectWH);// 先把图片绘制到上下文.UIGraphicsBeginImageContextWithOptions(self.imageView.bounds.size, NO, 0);// 获取当前的上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 把上面一张图片绘制到上下文.[self.imageView.layer renderInContext:ctx];// 再绘上下文当中图片进行擦除.CGContextClearRect(ctx, rect);// 生成一张新图片UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();// 再把新的图片给重新负值self.imageView.image = newImage;// 关闭上下文.UIGraphicsEndImageContext(); 图片截屏 思路 手指在屏幕上移动的时候，添加一个半透明的view 开启一个上下文把UIView的farme设置为裁剪区域 把view的layer显示的内容绘制到上下文当中 生成一张新的图片在赋值给UIImageView 具体实现 给图片添加一个手势，监听手指在图片上的拖动（注意UIImageView默认不能接收事件） 监听手指移动，手指移动时添加一个UIView，x,y就是起始点，手指开始的点，width是x轴的偏移量，height是y轴偏移量 计算代码123CGFloat offSetX = curP.x - self.beginP.x;CGFloat offsetY = curP.y - self.beginP.y;CGRect rect = CGRectMake(self.beginP.x, self.beginP.y, offSetX, offsetY); UIView只需要添加一次，给UIView设置成懒加载，保证只有一个UIView，在移动时修改frame就好 开启一个图片上下文，图片上下文的大小为位原始图片尺寸，是整个图片可以截取1234// 利用UIBezierPath设置一个矩形的裁剪区域// 然后把这个路径设置为裁剪区域// 把路径设为裁剪区域的方法为[path addClip]; 把图片绘制到上下文中12345// 由于是一个UIImageView上面的图片，所以也得需要渲染到上下文当中// 要先获取当前的上下文// 把UIImageView的layer渲染到当前的上下文当中CGContextRef ctx = UIGraphicsGetCurrentContext();[self.imageV.layer renderInContext:ctx]; 取出新的图片，重新赋值图片12UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();self.imageV.image = newImage; 关闭上下文,移除上面半透明的UIView12UIGraphicsEndImageContext();[self.coverView removeFromSuperview]; 手势解锁 分析界面 当手指在上面移动时，移动到按钮的一定范围中，会把按钮变成选中状态 并把第一个选中的按钮中心作为一条线的起点，手指移到下一个按钮就会添加一条线 手指松开后就会取消选中，清空所有线 思路 先判断当前手指在不在当前按钮上，如果在按钮上，就把按钮设置成选中状态 把当前选中的按钮添加到一个数组当中，如果当前按钮已经是选中状态，就不需要再添加到数组中了 每次移动都让它重绘，在绘图中，遍历所有选中按钮 判断数组当中的第一个无素，如果是第一个，那么就把它设为路径的起点，其它都在添加一根线到按钮的圆心 如果当前点不在按钮上，那么就记录住当前手指所在的点，直接从起点添加一根线到当前手指所在的点 具体实现 搭建界面界面是一个九宫格的布局.九宫格实现思路.先确定有多少列 cloum = 3;计算出每列之间的距离计算为: CGFloat margin = (当前View的宽度 - 列数 * 按钮的宽度) / 总列数 + 1每一列的X的值与它当前所在的行有关当前所在的列为:curColum = i % cloum每一行的Y的值与它当前所在的行有关.当前所在的行为:curRow = i / cloum每一个按钮的X值为, margin + 当前所在的列 * (按钮的宽度 + 每个按钮之间的间距)每一个按钮的Y值为 当前所在的行 * (按钮的宽度 + 每个按钮之间的距离)具体代码1234567891011121314151617// 总列数int colum = 3;// 每个按钮的宽高CGFloat btnWH = 74;// 每个按钮之间的距离CGFloat margin = (self.bounds.size.width - colum * btnWH) (colum + 1);for(int i = 0; i &lt; self.subviews.count; i++ ){// 当前所在的列int curColum = i % colum;// 当前所在的行int curRow = i / colum;CGFloat x = margin + (btnWH + margin) * curColum;CGFloat y = (btnWH + margin) * curRow;// 取出所有的子控件UIButton *btn = self.subviews[i];btn.frame = CGRectMake(x, y, btnWH, btnWH);} 监听手指在上面的操作在手指点击屏幕时，如果当前手指所在的点在按钮上，那就让按钮变成选中状态判断一个点在不在一个区域，在返回YES，不在NOCGRectContainsPoint(btn.frame, point)当手指点击屏幕的时候，需要做的事情：(1) 获取当前手指所在的点UITouch *touch = [touches anyObject];GPoint curP = [touch locationInView:self];(2) 判断当前点在不在按钮上for (UIButton *btn in self.subviews) {if (CGRectContainsPoint(btn.frame, point)) {return btn;}}(3) 如果当前点在按钮上，并且当前按钮不是选中的状态那么把当前的按钮成为选中状态并且把当前的按钮添加到数组当中 在绘图方法中创建路径遍历出有的选中按钮，如果是第一个按钮，把第一个按钮的中心点当做是路径的起点其它按钮都直接添加一条线，到该按钮的中心遍历完所有的选中按钮后最后添加一条线到当前手指所在的点 画板 分析顶部是一个工具栏。有清屏、撤销、橡皮擦、照片功能，最右部是一个保存按钮中间部分为画板区域最下部拖动滑块能够改变画笔的粗线，可以选颜色 界面搭建最上部为一个ToolBar，往ToolBar拖些item，使用ToolBar的好处，里面按钮的位置不需要我们再去管理给最上部的工具栏做自动布局，离父控件左、上、右都为0，保存工具条的高度不变拖一个UIView当前下部的View，在下部的View当中拖累三个按钮，设置每一个按钮的背景颜色，点击每一按钮时办到设置画笔的颜色其中三个按钮只间的间距始终保存等，每一个按钮的宽度和高度都相等，通过自动布局的方式办到先把这个UIView的自动布局设好，让其左、右、下都是0，高度固定自动布局设置为：第一个按钮高度固定，与左、右、下都保持20间距第二个按钮与第一个按钮，高度、宽度、centerY都相等，与右边有20间距第三个按钮也是第一个按钮的高度、宽度、centerY都相等，与右边有20间距，最右边也保持20间距最后是中间的画板区域，画板区域只需要距离上、下、左、右都为0即可 画板功能 监听手指在屏幕上的状态，在开始点击屏幕的时候，创建一个路径，并把手指当前的点设为路径的起点 设置一个成员属性记录当前绘制的路径，并把当前的路径添加到路径数组当中 当手指在移动的时候，用当前的路径添加一根线到当前手指所在的点，然后进行重绘 在绘图方法当中，取出所有的路径，把所有的路径给绘制出来 小工具 清屏删除所有路径，进行重绘 撤销删除最后一条路径，进行重绘 线宽由于每一条线宽度都不样，所以要在开始创建路径的时，就要添加一个成员属性，设置一个默认值在把当前路径添加到路径数组之前，设置好线的宽度，然后重写线宽属性方法下一次再创建路径时，线的宽度就是当前设置的宽度 颜色每一条线的颜色也不一样，也需要一个属性记录每一条路径的颜色UIBezierPath没有给我们直接提供设置颜色的属性，需要自定义一个UIBezierPath，创建一个MyBezierPath类，继承UIBezierPath，在该类中添加一个颜色的属性在创建路径的时候，直接使用自己定义的路径，设置路径默认的一个颜色，方法给设置线宽一样在绘图过程中，取出来的都是MyBezierPath，把MyBezierPath的颜色设置为路径的颜色 橡皮擦功能路径的颜色设为白色 保存功能 开启一个跟View相同大小的图片上下文 把View的layer上面内容渲染到上下文当中 生成一张图片，把图片保存到上下文12345// 第一个参数：要写入到相册的图片// 第二个参数：哪个对象坚听写入完成时的状态// 第三个参数：图片保存完成时调用的方法UIImageWriteToSavedPhotosAlbum(newImage, self, @selector(image:didFinishSavingWithError: contextInfo:), nil);// 注意:图片保存完成时调用的方法必须得是image:didFinishSavingWithError: contextInfo: 选择图片 弹出系统相册123456789// 使用UIImagePickerController控件器Modal出它来.UIImagePickerController *pick = [[UIImagePickerController alloc] init];// 设置照片的来源pick.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;// 设置代码，监听选择图片，UIImagePickerController比较特殊，它需要遵守两个协议&lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt;pick.delegate = self;// modal出控件器[self presentViewController:pick animated:YES completion:nil];// 注意没有实现代码方法时，选择一张照片会自动的dismiss掉相册控制器，但是设置代码后，就得要自己去dismiss了 实现代理，取得照片12345// 选择的照片就在这个方法第二个参数当中, 它是一个字典- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(nonnull NSDictionary&lt;NSString *,id&gt; *)info {// 获取当前选中的图片,通过UIImagePickerControllerOriginalImage就能获取UIImage *image = info[UIImagePickerControllerOriginalImage];} 得到照片的布局获取完图片后，图片是能够缩放、平移的，因此获取完图片后，是在画板板View上面添加了一个UIView，只有UIView才能做平移、缩放、旋转等操作因此做法为，在图片选择完毕后，添加一个和画板View相同大小的UIView，这个UIView内部有一个UIImageView对这个UIImageView进行一些手势操作，操作完成时，长按图片，把View的内容截屏，生成一张图片，把新生成的图片绘制到画板上面 绘制图片在画板View当中提供一个UImage属性，供外界传递，重写属性的set方法，每次传递图片时进行重绘画图片也有有序的，所以要把图片也添加到路径数组当中在绘图片过过程当中，如果发现取出来的是一个图片类型，那就直接图片绘制到上下文当中具体代码1234567891011- (void)drawRect:(CGRect)rect{for (DrawPath *path in self.pathArray) {if ([path isKindOfClass:[UIImage class]]) {UIImage *image = (UIImage *)path;[image drawInRect:rect];}else {[path.lineColor set];[path stroke];}}}","link":"/2016/09/01/my-ios-day13/"},{"title":"my-ios-day14","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 14核心动画 CALayer 核心动画 CALayer 简介CALayer有称它为“层”每一个UIView内部都有一个layer这样的属性UIView之所以可以显示，就是因为它里面有这样一个层，才具有显示功能我们通过操作CALayer对象，可以方便的调整UIView的外观属性可以给UIView设置阴影、圆角、边框等 操作layer 设置阴影123456// 默认图层是有阴影的，只不过是透明的_redView.layer.shadowOPacity = 1;// 设置阴影的圆角_redView.layer.shadowRadius = 10;// 设置阴影的颜色_redView.layer.shadowColor = [UIColor blueColor].CGColor; 设置边框123// 设置图层边框，在图层中使用CoreGraphics的CGColoerRef_redView.layer.borderColor = [UIColor whiteColor].CGColor;_redView.layer.borderWidth = 2; 设置圆角12// 图层的圆角半径，若为宽度一般就是一个圆_redView.layer.cornerRadius = 50; layer改变UIImageView 设置边框12_imageView.layer.borderWidth = 2;_imageView.layer.borderColor = [UIColor whiteColor].CGColor; 图片圆角1234// 半径_imageView.layer.cornerRadius = 50;// 裁剪_imageView.layer.masksToBounds = YES; 注意：UIImageView当中Image并不是直接添加在图层上，而是在layer的contents里。设置的属性只是作用在层上，如果不裁剪的话是不能看见图片的圆角的 layer的CATransform3D属性 只有旋转的时候在会看到3D效果1234567// x, y, z分别代表x, y, z轴// 旋转CATransform3DMakeRotation(M_PI, 1, 0, 0);// 平移CATransform3DMakeTranslation(x, y, z);// 缩放CATransform3DMakeScale(x, y, z); 可以通过KVC的方式进行设置属性 CATransform3DMake*的值是一个结构体，要把结构体转换成对象12NSValue *value = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 1, 0, 0)];[_imageView.layer setValue:value forKeyPath:@&quot;transform.scale&quot;]; 何时使用当需要进行快速的缩放、平移、旋转的时候使用KVC如[_imageView.layer setValue:@0.5 forKeyPath:@”transform.scale”];后面的forKeyPath不是乱写的，苹果文档有给出 自定义UILayer 与在定义UIView相似12345CALayer *layer = [CALayer layer];layer.frame = CGRectMake(50, 50, 100, 100);layer.backgroundColor = [UIColor redColor].CGColor;// 给Layer添加图片layer.contents = (id)[UIImage imageNamed:@&quot;xixi&quot;].CGImage; 关于CALayer为什么要使用CGImageRef，CGColorRef？保证了可移植性，QuartzCore不能使用UIImage、UIColor，只能用CGImageRef，CGColorRefUIView和CALayer都能够显示东西，该怎样选择?对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级 position和anchorPoint属性 是Layer的两个属性 可以通过这两个属性修改控件的位置，他们两个是配合使用的posrtion：它是用来设置当前控件在父控件中的位置的它的坐标原点是父控件的左上角为(0, 0)点anchorPoint：它是决定CALayer身上哪一个点会在postion属性所指的位置，它以当前图层左上角为原点(0, 0)取值范围0~1，默认在中间位置(0.5, 0.5)位置又称锚点，就是把锚点定在position的位置 两者结合使用 设置它的position点 layer身上的anchorPoint会自动定在position所在的位置 隐式动画 两个概念 根层：UIView内部关联的哪个layer称为根层 非根层：自己手动创建的layer就是非根层 在对非根层修改时，会自动产生一些动画效果，为隐式动画 取消隐式动画 事务：很多操作绑定在一起，这些操作按顺序执行， 动画底层就是包装成事务进行的12345678// 开启事务[CATransaction begin];// 设置事务没有动画[CATransaction setDisableActions:YES];// 设置动画执行的时长[CATransaction setAnimationDuration:2];// 提交事务[CATransaction commit]; 核心动画 简介 Core Animation，非常强大的动画处理API。通过很少的代码完成功能很炫的效果 同时可以应用于Mac OS X和iOS 所有动画都是在后台执行，不会阻塞主线程 直接作用于CALayer层，非UIView 使用步骤 首先要有一个layer 初始化一个CAAnimation对象，并设置相应的属性 通过调用CALayer的addAnimation: forKey:方法，添加CAAnimation对象到CALayer中， 调用CALayer的removeAnimation: forKey:方法，停止CALayer中的动画 属性说明 12345678duration：动画的持续时间repeatCount：重复次数，无限循环可以设置HUGE_VALF或者MAXFLOATrepeatDuration：重复时间removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上 移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画 执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillMod eForwardsfillMode：决定当前对象在非active时间段的行为。比如动画开始之 前或者动画结束之后beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为 CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间timingFunction：速度控制函数，控制动画运行的节奏delegate：动画代理 动画填充模式 fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO） 1234kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态 速度控制函数 速度控制函数CAMediaTimingFunction 1234kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。 动画的代理 CAAnimation在分类中定义了代理方法 123456@interface NSObject (CAAnimationDelegate)// 动画开始的时候调用- (void)animationDidStart:(CAAnimation *)anim;// 动画完成，移除时调用- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;@end 动画的暂停和恢复 暂停 1234567- (void)pauseLayer:(CALayer *)layer {CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];// 让CALayer的时间停止走动layer.speed = 0.0;// 让CALayer的时间停留在pausedTime这个时刻layer.timeOffset = pausedTime;} 恢复 12345678910111213- (void)resumeLayer:(CALayer *)layer {CFTimeInterval pausedTime = layer.timeOffset;// 1. 让CALayer的时间继续行走layer.speed = 1.0;// 2. 取消上次记录的停留时刻layer.timeOffset = 0.0;// 3. 取消上次设置的时间layer.beginTime = 0.0;// 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;// 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)layer.beginTime = timeSincePause;} 基础动画CABasicAnimation CAPropertyAnimation的子类 属性说明 12fromValue：keyPath相应属性的初始值toValue：keyPath相应属性的结束值 过程 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue keyPath内容是CALayer的可动画Animatable属性 如果fillMode=kCAFillModeForwards同时removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。 关键帧动画CAKeyframeAnimation CAPropertyAnimation的子类 区别： CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue） CAKeyframeAnimation会使用一个NSArray保存这些数值 属性说明 123values：上述的NSArray对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧path：可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 组动画CAAnimationGroup CAAnimation的子类 可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行 属性说明 12animations：用来保存一组动画对象的NSArray默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间 转场动画CATransition CAAnimation的子类 能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点 属性说明 1234type：动画过渡类型subtype：动画过渡方向startProgress：动画起点(在整体动画的百分比)endProgress：动画终点(在整体动画的百分比) 应用 1234567891011121314151617/*** UIView单视图转场动画函数* duration：动画的持续时间* view：需要进行转场动画的视图* options：转场动画的类型* animations：将改变视图属性的代码放在这个block中* completion：动画结束后，会自动调用这个block*/+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;/*** UIView双视图转场动画函数* duration：动画的持续时间* options：转场动画的类型* animations：将改变视图属性的代码放在这个block中* completion：动画结束后，会自动调用这个block*/+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 小实例 钟表效果 分析界面上时针、分针、秒针不需要与用户进行交互，所以都可以使用layer方式来做表针是根据当前的时间，绕着表盘的中心点进行旋转无论是旋转，缩放它都是绕着锚点进行的要想让时针、分针、称针显示的中间，还要绕着中心点进行旋转，那就要设置它的position和anchorPoint两个属性. 实现 秒针12345678// 创建秒针CALayer *layer = [CALayer layer];_secLayer = layer;layer.bounds = CGRectMake(0, 0, 1, 80);layer.anchorPoint = CGPointMake(0.5, 1);layer.position = CGPake(_clockView.bounds.size.width * 0.5, _clew.bounds.size.height * 0.5);layer.backgroundColor = [UIColor redColor].CGColor;[_clockView.layer addSublayer:layer]; 123456789101112131415161718192021让秒针旋转，所以要计算当前的旋转度是多少?当前的旋转角度为：当前的时间 * 每秒旋转多少度计算每一秒旋转多少度60 秒转一圈360度360 除以60就是每一秒转多少度，每秒转6度获取当前的时间创建日历类NSCalendar *calendar = [NSCalendar currentCalendar];把日历类转换成一个日期组件日期组件（年、月、日、时、分、秒）component:日期组件有哪些东西组成,他是一个枚举,里面有年月日时分秒fromDate:当前的日期NSDateComponents *cmp = [calendar components:NSCalendarUnitSecond fromDate:[NSDate date]];我们的秒就是保存在日期组件里面，它里面提供了很多get方法。NSInteger second = cmp.second;那么当前秒针旋转的角度就是当前的秒数乘以每秒转多少度econd * perSecA还得要把角度转换成弧度因为下面分针，时针也得要用到，就把它抽出一个速参数的宏。#define angle2Rad(angle) ((angle) / 180.0 * M_PI) 123456789101112131415161718192021// 让它每隔一秒旋转一次.所以添加一个定时器.// 每个一秒就调用,旋转秒针- (void)timeChange {// 获取当前的秒数// 创建日历类NSCalendar *calendar = [NSCalendar currentCalendar];// 把日历类转换成一个日期组件// 日期组件(年、月、日、时、分、秒)// component:日期组件有哪些东西组成，他是一个枚举，里面有年月日时分秒// fromDate:当前的日期NSDateComponents *cmp = [calendar components:NSCalendarUnitSecond fromDate:[NSDate date]];// 我们的秒就是保存在日期组件里面，它里面提供了很多get方法NSInteger second = cmp.second;// 秒针旋转多少度CGFloat angel = angle2Rad(second * perSecA);// 旋转秒针self.secondL.transform = CATransform3DMakeRotation(angel, 0, 0, 1);}// 运行发现他会一下就跳到某一个时间才开始旋转// 一开始的时候就要来到这个方法，获取当前的秒数把它定位好// 要在添加定时器之后就调用一次timeChange方法 分针1234567891011代码基本相同，添加一个分针成员属性修改宽度，修改颜色，让它旋转要算出每分钟转多少度转60分钟刚好是一圈，所以每一分钟也是转6度获取当前多少分?同样是在日期组件里面获得里面有左移符号,右移符号.他就可以用一个并运算现在同时让他支持秒数和分 后面直接加上一个 |NSDateComponents *cmp = [calendar components:NSCalendarUnitSecond | NSCalendarUnitMinute fromDate:[NSDate date]];CGFloat minueteAngel = angle2Rad(minute * perMinuteA);self.minueL.transform = CATransform3DMakeRotation(minueteAngel, 0, 0, 1); 时针1234567小时转多少度当前是多少小时，再计算先每一小时转多少度12个小时转一圈，360除以12，每小时转30度时针旋转多少度CGFloat hourAngel = angle2Rad(hour * perHourA);旋转时针self.hourL.transform = CATransform3DMakeRotation(hourAngel, 0, 0, 1); 直接这样写会有问题就是每转一分钟，小时也会移动一点点接下来要算出，每一分钟，小时要转多少度60分钟一小时，一小时转30度30 除以60，就是每一分钟，时针转多少度0.51234// 时针旋转多少度CGFloat hourAngel = angle2Rad(hour * perHourA + minute * perMinuteHourA);// 旋转时针self.hourL.transform = CATransform3DMakeRotation(hourAngel, 0, 0, 1); 心跳效果 思路：就是让一张图片做一个放大缩小的持续动画 代码实现12345678910111213CABasicAnimation *anim =[CABasicAnimation animation];// 设置缩放属性anim.keyPath = @&quot;transform.scale&quot;;// 缩放到最小anim.toValue = @0;// 设置动画执行的次数anim.repeatCount = MAXFLOAT;// 设置动画执行的时长anim.duration = 0.25;// 设置动画自动反转(怎么去, 怎么回)anim.autoreverses = YES;// 添加动画[self.heartView.layer addAnimation:anim forKey:nil]; 图片抖动 思路：其实就是做一个左右旋转的动画。先让它往左边旋转-5，再往右边旋转5度，再从5度旋转到-5度，就会有左右摇摆的效果了。 实现12345678910// 创建帧动画CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];// 设置动画属性为旋转anim.keyPath = @&quot;transform.rotation&quot;;// 设置属性值为多个属性anim.values = @[@(angle2radio(-5)), @(angle2radio(5)), @(angle2radio(-5))];// 设置动画执行次数anim.repeatCount = MAXFLOAT;// 添加动画[_imageView.layer addAnimation:anim forKey:nil]; 转盘 界面把转盘View给封装起来，界面是固定不变的，可以使用一个Xib展示界面外界使用时直接来一个类方法直接调用 旋转内部提供开始和结束旋转，供外界调用 按钮按钮是倾斜的，排列在一周，先将所有按钮添加到最上方，让按钮绕着圆盘中心进行旋转锚点设置为按钮底部中心(0.5, 1)，按钮的position为圆盘中心添加按钮时，让每一个按钮进行旋转，计算出每一个按钮旋转的角度：总共有12个按钮,正好占圆的一圈，那每一个按钮占30一个按钮在上一个按钮的基础上加上30，即可算出每一个按钮旋转的角度 点击事件 在添加按钮时，给每个按钮加选中状态（默认UIImageView不能交互，手动设置） 点击后按钮称为选中，上一个按钮取消选中状态 按钮图片 美工图片为一整张图片，需要自己裁剪，确定裁剪的宽高 使用下面方法裁剪1234567// image:为要裁剪的图片，既原始图片。它的类型为CGImageRef类型，所以要转成CGImage// rect:为裁剪的范围.这时需要确定每一个X的位置// 每一个x为它当前的角标 * 要裁剪的宽度CGImageCreateWithImageInRect(image, rect);// 这个方法它会返回一个图片.图片类型为CGImageRef imgR.// 所要我们在设置背景图片的时候，要把这张图片给转成UIImage，转的方法为:UIImage *image = [UIImage imageWithCGImage:imgR]; 问题123CGImageCreateWithImageInRect方法为C语言方法，裁剪的时候是按像素，而iOS是使用点，需要乘以像素比例[UIScreen mainScreen].scale 中间按钮 逻辑：快速的让圆盘旋转几圈，动画完成时，让选择的按钮指上最上方，使用核心动画 在动画结束后获得旋转角度123456CGFloat angel = atan2(self.selectBtn.transform.b, self.selectBtn.transform.a);- (void)animationDidStop:(nonnull CAAnimation *)anim finished:(BOOL)flag {CGAffineTransform transform = self.selectBtn.transform;CGFloat angel = atan2(self.selectBtn.transform.b, self.selectBtn.transform.a);self.innerCircle.transform = CGAffineTransformMakeRotation(-angel);}","link":"/2016/09/01/my-ios-day14/"},{"title":"my-ios-day15","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 15彩票项目 √ 主流框架 x 新特性界面 x 设置界面 主流框架搭建 主流框架 一个UITabBarController管理多个UINavigationController 框架使用纯代码方式 文件按照模块管理，内部为MVC模式 主要流程 创建单视图程序，配置项目基本信息 删除系统创建的main.storyboard和ViewController 配置General项删除Main Interface 配置禁止屏幕旋转，lunch界面隐藏状态栏 为AppIcon添加图片，给LunchScreen.storyboard设置图片 5. 按模块创建文件夹 在AppDelegate.m中初始化window12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {// 设置windowself.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];// 添加根控制器SLTabBarController *tabBar = [[SLTabBarController alloc] init];self.window.rootViewController = tabBar;// 让window显示[self.window makeKeyAndVisible];return YES;} 直接使用了自定义的SLTabBarController，在SLTabBarController中添加子控制器 按模块分别创建自己的控制器12345#import &quot;SLHallTableViewController.h&quot;#import &quot;SLArenaViewController.h&quot;#import &quot;SLDiscoverTableViewController.h&quot;#import &quot;SLHistoryTableViewController.h&quot;#import &quot;SLMyLotteryViewController.h&quot; 自定义TabBar 移除系统tabBar中的所有item12345678910111213141516// 在View将要出现的时候调用- (void)viewWillAppear:(BOOL)animated {[super viewWillAppear:animated];for (UIView *view in self.tabBar.subviews) {NSString *classStr = NSStringFromClass([view class]);// if ([classStr hasPrefix:@&quot;UITabBarButton&quot;]) {// [view removeFromSuperview];// }// if ([view isKindOfClass:[UIControl class]]) {// [view removeFromSuperview];// }if(![view isKindOfClass:[SLTabBar class]]) {[view removeFromSuperview];}}} 添加自定义SLTabBar1234SLTabBar *tabBar = [[SLTabBar alloc] initWithFrame:self.tabBar.bounds];tabBar.items = self.items;tabBar.delegate = self;[self.tabBar addSubview:tabBar]; 抽取添加控制器方法123456789101112131415- (void)setController:(UIViewController *)vc withImage:(NSString *)image selectImage:(NSString *)sImage title:(NSString *)title{// 包装导航控制器UINavigationController *nav =[[SLNavController alloc] initWithRootViewController:vc];// 竞技场的导航控制器不同if ([vc isKindOfClass:[SLArenaViewController class]]) {nav = [[SLArenaNavController alloc] initWithRootViewController:vc];}[self addChildViewController:nav];// 设置一些数据vc.title = title;vc.tabBarItem.image = [UIImage imageNamed:image];vc.tabBarItem.selectedImage = [UIImage imageNamed:sImage];// 保存数据，供SLTabBar使用[self.items addObject:vc.tabBarItem];} 为SLTabBar保存相应数据值12345678910111213@interface SLTabBar()/** 保存系统原有tabBarItem */@property (nonatomic, strong) NSMutableArray *items;@end@implementation SLTabBarController// 实现懒加载- (NSMutableArray *)items {if (_items == nil) {_items = [NSMutableArray array];}return _items;}@end SLTabBar.m根据items中添加按钮，layoutSubViews布局1234567891011121314151617181920212223242526- (void)setItems:(NSArray *)items {_items = items;for (UITabBarItem *item in items) {SLTabBarButton *btn = [SLTabBarButton buttonWithType:UIButtonTypeCustom];[btn setBackgroundImage:item.image forState:UIControlStateNormal];[btn setBackgroundImage:item.selectedImage forState:UIControlStateSelected];[btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchDown];[self addSubview:btn];}}- (void)layoutSubviews {CGFloat btnW = self.width / self.items.count;CGFloat btnH = self.height;CGFloat btnY = 0;CGFloat btnX = 0;for (int i= 0; i &lt; self.items.count; i++) {SLTabBarButton *btn = self.subviews[i];btnX = btnW * i;btn.frame = CGRectMake(btnX, btnY, btnW, btnH);btn.tag = i;if (i == 0) {btn.selected = YES;self.curButton = btn;}}} 监听代按钮点击，并使用代理切换控制器12345678910111213141516171819// 代理（SLTabBar.h）@protocol SLTabBarDelegate &lt;NSObject&gt;@optional- (void)tabBar:(SLTabBar *)tabBar changeIndex:(NSInteger)index;@end// 按钮点击（SLTabBar.m）- (void)btnClick:(SLTabBarButton *)btn {self.curButton.selected = NO;btn.selected = YES;self.curButton = btn;if ([self.delegate respondsToSelector:@selector(tabBar:changeIndex:)]) {[self.delegate tabBar:self changeIndex:btn.tag];}}// 代理实现（SLTarBarController.m）#pragma mark - tabBar代理方法- (void)tabBar:(SLTabBar *)tabBar changeIndex:(NSInteger)index {self.selectedIndex = index;} 自定义导航控制器SLNavController 在initialize中做一些全局设置1234567891011121314151617181920+ (void)initialize {// 当时这个类本身第一次加载的时候调用一次// 其子类加载时不调用if (self == [SLNavController self]) {// 获取全局导航条UINavigationBar *navBar = [UINavigationBar appearanceWhenContainedInInstancesOfClasses:@[self]];// 导航栏背景图片[navBar setBackgroundImage:[UIImage imageNamed:@&quot;NavBar64&quot;] forBarMetrics:UIBarMetricsDefault];// 导航栏标题属性NSMutableDictionary *dict = [NSMutableDictionary dictionary];dict[NSFontAttributeName] = [UIFont systemFontOfSize:22];dict[NSForegroundColorAttributeName] = [UIColor whiteColor];[navBar setTitleTextAttributes:dict];// 主题色navBar.tintColor = [UIColor whiteColor];// 移除返回按钮文字UIBarButtonItem *item = [UIBarButtonItem appearanceWhenContainedInInstancesOfClasses:@[self]];[item setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -64) forBarMetrics:UIBarMetricsDefault];}} 在各自的控制器中设置导航条左右按钮12345678910// SLMyLotteryViewController.h- (void)viewDidLoad {[super viewDidLoad];UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];[btn setImage:[UIImage imageNamed:@&quot;FBMM_Barbutton&quot;] forState:UIControlStateNormal];[btn setTitle:@&quot;客服&quot; forState:UIControlStateNormal];[btn sizeToFit];self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:btn];self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@&quot;Mylottery_config&quot;] style:UIBarButtonItemStylePlain target:self action:@selector(configClick)];} 竞技场导航条设置123456789101112131415161718192021222324252627282930313233// SLArenaNavController.h+ (void)initialize {if (self == [SLArenaNavController self]) {UINavigationBar *navBar = [UINavigationBar appearanceWhenContainedInInstancesOfClasses:@[self]];// 导航栏背景图片[navBar setBackgroundImage:[UIImage resizeImageName:@&quot;NLArenaNavBar64&quot;] forBarMetrics:UIBarMetricsDefault];// 导航栏标题NSMutableDictionary *dict = [NSMutableDictionary dictionary];dict[NSFontAttributeName] = [UIFont systemFontOfSize:22];dict[NSForegroundColorAttributeName] = [UIColor whiteColor];[navBar setTitleTextAttributes:dict];// 主题色navBar.tintColor = [UIColor whiteColor];// 移除返回按钮文字UIBarButtonItem *item = [UIBarButtonItem appearanceWhenContainedInInstancesOfClasses:@[self]];[item setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -64) forBarMetrics:UIBarMetricsDefault];}}// SLArenaViewController.m- (void)viewDidLoad {[super viewDidLoad];UISegmentedControl *seg = [[UISegmentedControl alloc] initWithItems:@[@&quot;足球&quot;, @&quot;篮球&quot;]];[seg setTitleTextAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:18],NSForegroundColorAttributeName : [UIColor whiteColor]}forState:UIControlStateNormal];[seg setBackgroundImage:[UIImage imageNamed:@&quot;CPArenaSegmentBG&quot;] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];[seg setBackgroundImage:[UIImage imageNamed:@&quot;CPArenaSegmentSelectedBG&quot;] forState:UIControlStateSelected barMetrics:UIBarMetricsDefault];seg.tintColor = SLColor(52, 137, 140, 1);seg.selectedSegmentIndex = 0;self.navigationItem.titleView = seg;} 每个控制器的逻辑 SLHallTableViewController（谁创建谁移除） 导航条左边按钮 1234- (void)viewDidLoad {[super viewDidLoad];self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageWithOriginal:@&quot;CS50_activity_image&quot;] style:UIBarButtonItemStylePlain target:self action:@selector(leftClick)];} 左边按钮点击事件，添加popMenu 12345- (void)leftClick {[SLMaskView show];SLPopMenu *popMenu = [SLPopMenu popMenuShowInCenter:self.view.center];popMenu.delegate = self;} SLPopMenu代理 1234567- (void)popMenu:(SLPopMenu *)menu cancelBtnClick:(UIButton *)btn {[menu hiddenInCenter:CGPointMake(44, 44) completion:^{[UIView animateWithDuration:0.25 animations:^{[SLMaskView hidden];}];}];} 自定义蒙版 123456789101112131415161718192021222324// SLMaskView.h@interface SLMaskView : UIView+ (void)show;+ (void)hidden;@end// SLMaskView.m@implementation SLMaskView// static SLMaskView *mask;+ (void)show {SLMaskView *mask = [[SLMaskView alloc] initWithFrame:[UIScreen mainScreen].bounds];mask.backgroundColor = [UIColor blackColor];mask.alpha = 0.7;[SLKwyWindow addSubview:mask];}+ (void)hidden {for (UIView *view in SLKwyWindow.subviews) {if ([view isKindOfClass:[self class]]) {[view removeFromSuperview];}}// [mask removeFromSuperview];// mask = nil;}@end 自定义popMenu 123456789101112131415161718192021// SLPopMenu.h@class SLPopMenu;@protocol SLPopMenuDelegate &lt;NSObject&gt;@optional- (void)popMenu:(SLPopMenu *)menu cancelBtnClick:(UIButton *)btn;@end@interface SLPopMenu : UIView/*** 创建一个SLPopMenu，* center：popMenu的中心位置*/+ (instancetype)popMenuShowInCenter:(CGPoint)center;/*** 隐藏popMenu* center：popMenu隐藏到哪里* completion：隐藏后做一些事情*/- (void)hiddenInCenter:(CGPoint)center completion:(void(^)())completion;/** 代理 */@property (nonatomic, weak) id&lt;SLPopMenuDelegate&gt; delegate;@end 123456789101112131415161718192021222324// SLPopMenu.m@implementation SLPopMenu+ (instancetype)popMenuShowInCenter:(CGPoint)center {SLPopMenu *popMenu = [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass([self class]) owner:nil options:nil] lastObject];popMenu.center = center;[SLKwyWindow addSubview:popMenu];return popMenu;}- (IBAction)cancelBtnClick:(UIButton *)btn {if ([self.delegate respondsToSelector:@selector(popMenu:cancelBtnClick:)]) {[self.delegate popMenu:self cancelBtnClick:btn];}}- (void)hiddenInCenter:(CGPoint)center completion:(void (^)())completion {[UIView animateWithDuration:0.5 animations:^{self.transform = CGAffineTransformMakeScale(0.01, 0.01);self.center = center;} completion:^(BOOL finished) {[self removeFromSuperview];if (completion) {completion();}}];} SLArenaViewController（loadView方法）123456- (void)loadView {UIImageView *imView = [[UIImageView alloc] initWithFrame:[UIScreen mainScreen].bounds];imView.image = [UIImage imageNamed:@&quot;NLArenaBackground&quot;];imView.userInteractionEnabled = YES;self.view = imView;} SLDiscoverTableViewController（storyboard，cell动画） 界面固定使用storyboard创建12UIStoryboard *storyboard = [UIStoryboard storyboardWithName:NSStringFromClass([SLDiscoverTableViewController class]) bundle:nil];SLDiscoverTableViewController *discover = [storyboard instantiateInitialViewController]; cell的动画123456- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {cell.transform = CGAffineTransformMakeTranslation(self.view.width, 0);[UIView animateWithDuration:0.5 animations:^{cell.transform = CGAffineTransformIdentity;}];} 按钮内部控件位置调整1234567891011121314151617181920212223// SLTitleButton.m// 调整所有子控件的位置- (void)layoutSubviews{[super layoutSubviews];if (self.imageView.x &lt; self.titleLabel.x) { // 第一次调整两个控件的位置// 这个方法调用了两次,这个位置调整了两次// 1.调整label的位置self.titleLabel.x = self.imageView.x;// 2.调整imageView的位置self.imageView.x = CGRectGetMaxX(self.titleLabel.frame);}}- (void)setTitle:(NSString *)title forState:(UIControlState)state {// 做完自己的事情之后 还原系统原有的方法[super setTitle:title forState:state];// 增加自己的方法// 自动计算尺寸[self sizeToFit];}- (void)setImage:(UIImage *)image forState:(UIControlState)state {[super setImage:image forState:state];[self sizeToFit];} 手指滑动切换控制器123456789101112131415161718// SLNavController.m- (void)viewDidLoad {[super viewDidLoad];UIScreenEdgePanGestureRecognizer *gesture = (UIScreenEdgePanGestureRecognizer *)self.interactivePopGestureRecognizer;NSArray *targets = [gesture valueForKeyPath:@&quot;_targets&quot;];// 取出targetid target = [targets[0] valueForKeyPath:@&quot;_target&quot;];// 禁止系统的self.interactivePopGestureRecognizer.enabled = NO;UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];[self.view addGestureRecognizer:pan];pan.delegate = self;}// 返回YES收拾可以交互, 返回NO不能交互- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {// != 1 非跟控制器 &gt; 1return self.childViewControllers.count &gt; 1;} 隐藏TabBar底部的导航条12345678// SLNavController.m- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {// 一定要写在前面才有用，if (self.childViewControllers.count != 0) {viewController.hidesBottomBarWhenPushed = YES;}[super pushViewController:viewController animated:animated];}","link":"/2016/09/01/my-ios-day15/"},{"title":"my-ios-day16","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 16彩票项目 √ 主流框架 √ 新特性界面 √ 设置界面 新特性界面 UICollectionView 拥有和UITableView一样的重用机制，但需要自己布局cell 系统提供UICollectionViewFlowLayout类来布局cell 使用步骤 设置布局参数12345678UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];flowLayout.itemSize = [UIScreen mainScreen].bounds.size;// 滚动方向(水平)flowLayout.scrollDirection = UICollectionViewScrollDirectionHorizontal;// items 和items之间的间距flowLayout.minimumInteritemSpacing = 0;// 行间距flowLayout.minimumLineSpacing = 0; 注册cell1[self.collectionView registerClass:[XMGNewFeatureCollectionViewCell class] forCellWithReuseIdentifier:reuseIdentifier]; 新特性 添加NewFeature文件夹 自定义SLCollectionViewController : UICollectionVieController 布局collectionView 12345678910111213- (instancetype)init {// 创建流水布局UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];// 行间距flowLayout.minimumLineSpacing = 0;// 列间距flowLayout.minimumInteritemSpacing = 0;// 每个cell的尺寸flowLayout.itemSize = [UIScreen mainScreen].bounds.size;// 滚动方向，水平滚动flowLayout.scrollDirection = UICollectionViewScrollDirectionHorizontal;return [super initWithCollectionViewLayout:flowLayout];} 注册cell，设置属性，添加图片 12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad {[super viewDidLoad];// Register cell classes[self.collectionView registerClass:[SLNewFeatureCollectionViewCell class] forCellWithReuseIdentifier:reuseIdentifier];// 设置分页self.collectionView.pagingEnabled = YES;// 取消弹簧效果self.collectionView.bounces = NO;// 取消滚动条self.collectionView.showsHorizontalScrollIndicator = NO;// 添加图片[self addImageView];}- (void)addImageView {// guide1UIImageView *guideImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;guide1&quot;]];[self.collectionView addSubview:guideImageView];guideImageView.x += 50;self.guideImageView = guideImageView;// guideLineUIImageView *guideLineImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;guideLine&quot;]];[self.collectionView addSubview:guideLineImageView];guideLineImageView.x -= 150;// guideLargeText1UIImageView *guideLargeTextImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;guideLargeText1&quot;]];[self.collectionView addSubview:guideLargeTextImageView];guideLargeTextImageView.center = CGPointMake(self.collectionView.width * 0.5f, self.collectionView.height * 0.7);self.guideLargeTextImageView = guideLargeTextImageView;// guideSmallText1UIImageView *guideSmallTextImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;guideSmallText1&quot;]];[self.collectionView addSubview:guideSmallTextImageView];guideSmallTextImageView.center = CGPointMake(self.collectionView.width * 0.5f, self.collectionView.height * 0.8);self.guideSmallTextImageView = guideSmallTextImageView;} 设置图片的动画 12345678910111213141516171819202122232425262728293031// 当scrollView 减速的时候调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{// 当前偏差CGFloat offsetX = scrollView.contentOffset.x;// 计算页码NSInteger page = offsetX / scrollView.width + 1;// 换图片NSString *name = [NSString stringWithFormat:@&quot;guide%ld&quot;,page];UIImage *image = [UIImage imageNamed:name];self.guideImageView.image = image;// 大标题NSString *largeTextname = [NSString stringWithFormat:@&quot;guideLargeText%ld&quot;,page];UIImage *largeTextimage = [UIImage imageNamed:largeTextname];self.guideLargeTextImageView.image = largeTextimage;// 小标题NSString *smallTextname = [NSString stringWithFormat:@&quot;guideSmallText%ld&quot;,page];UIImage *smallTextimage = [UIImage imageNamed:smallTextname];self.guideSmallTextImageView.image = smallTextimage;// 偏差值CGFloat del = offsetX - self.lastOffsetX;self.guideImageView.x += del * 2;self.guideLargeTextImageView.x += del * 2;self.guideSmallTextImageView.x += del * 2;[UIView animateWithDuration:0.25f animations:^{self.guideImageView.x -= del;self.guideLargeTextImageView.x -= del;self.guideSmallTextImageView.x -= del;}];// 记录上次偏差self.lastOffsetX = offsetX;} 设置cell样式 12345678- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath {SLNewFeatureCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdentifier forIndexPath:indexPath];NSString *imageName = [NSString stringWithFormat:@&quot;guide%ldBackground&quot;,indexPath.item + 1];cell.image = [UIImage imageNamed:imageName];// 判断是否是最后一个cell[cell setIndexPath:indexPath count:SLPageCount];return cell;} 自定义cell，添加bg图片、立即体验 提供图片属性12/** 背景图片 */@property (nonatomic, strong) UIImage *image; 添加bgImageView1234567- (UIImageView *)bgImageView {if (!_bgImageView) {_bgImageView = [[UIImageView alloc] initWithFrame:self.bounds];[self.contentView addSubview:_bgImageView];}return _bgImageView;} 重写image的set方法12345- (void)setImage:(UIImage *)image {_image = image;// 设置imageself.bgImageView.image = image;} 提供设置立即体验方法12345678910- (void)setIndexPath:(NSIndexPath *)indexPath count:(NSInteger)count {// 当时最后一个cell的时候，添加立即体验按钮if (indexPath.item + 1 == count) {// 添加立即体验按钮self.startBtn.hidden = NO;}else { // 不是最后一个cell// 隐藏立即体验按钮self.startBtn.hidden = YES;}} 立即体验按钮123456789101112131415161718- (UIButton *)startBtn {if (_startBtn == nil) {_startBtn = [[UIButton alloc] init];[_startBtn setBackgroundImage:[UIImage imageNamed:@&quot;guideStart&quot;] forState:UIControlStateNormal];[_startBtn sizeToFit];// 一定要在按钮有尺寸的时候，再调整位置_startBtn.center = CGPointMake(self.contentView.width * 0.5f, self.contentView.height * 0.9f);[_startBtn addTarget:self action:@selector(startBtnOnclick:) forControlEvents:UIControlEventTouchUpInside];[self.contentView addSubview:_startBtn];}return _startBtn;}// 开始按钮点击调用的方法- (void)startBtnOnclick:(UIButton *)button {SLTabBarController *tabBarVc = [[SLTabBarController alloc] init];// 切换跟控制器SLKeyWindow.rootViewController = tabBarVc;} 工具类 在Other文件夹中添加Tool文件夹 数据存数工具SLSaveTool1234567891011121314151617181920// SLSaveTool.h@interface SLSaveTool : NSObject+ (id)objectForKey:(NSString *)defaultName;+ (void)setObject:(id)value forKey:(NSString *)defaultName;@end// SLSaveTool.m@implementation SLSaveTool+ (id)objectForKey:(NSString *)defaultName {return [[NSUserDefaults standardUserDefaults] objectForKey:defaultName];}+ (void)setObject:(id)value forKey:(NSString *)defaultName {// 偏好设置不能存储nilif (defaultName) {// 保存当前版本[[NSUserDefaults standardUserDefaults] setObject:value forKey:defaultName];// 立即同步[[NSUserDefaults standardUserDefaults] synchronize];}}@end 根控制器选择工具SLRootVCTool1234567891011121314151617181920212223242526272829// SLRootVCTool.h@interface SLRootVCTool : NSObject/*** 选择窗口的跟控制器*/+ (UIViewController *)chooseWindowRootVc;@end// SLRootVCTool.m@implementation SLRootVCTool+ (UIViewController *)chooseWindowRootVc {UIViewController *rootVc;// 取出当前版本NSString *currVerson = [NSBundle mainBundle].infoDictionary[@&quot;CFBundleShortVersionString&quot;];// 取出上一次保存的版本NSString *odlVerson = [SLSaveTool objectForKey:SLVerson];// 判断有无新版本if ([currVerson isEqualToString:odlVerson]) {// 没有新版本，进入主框架// 设置窗口的根控制器rootVc = [[SLTabBarController alloc] init];}else {// 有新版本// 显示新特性界面rootVc = [[SLNewFeatureViewController alloc] init];[SLSaveTool setObject:currVerson forKey:SLVerson];}return rootVc;}@end 设置界面 分析 界面较多，但内部结构基本相同， 使用纯代码，并依据MVC开发 添加Setting文件夹 设置组模型SLSettingGroup123456789101112131415161718192021// SLSettingGroup.h@interface SLSettingGroup : NSObject/** cell模型数组 */@property (nonatomic, strong) NSArray *items;/** 头部标题 */@property (nonatomic, copy) NSString *headerTitle;/** 尾部标题 */@property (nonatomic, copy) NSString *footTitle;/*** 通过cell模型数组返回组模型*/+ (instancetype)groupWithItems:(NSArray *)items;@end// SLSettingGroup.m@implementation SLSettingGroup+ (instancetype)groupWithItems:(NSArray *)items{SLSettingGroup *group = [[SLSettingGroup alloc] init];group.items = items;return group;}@end 设置cell模型 基本的cell，12345678910111213141516171819202122232425// SLSettingItem.h@interface SLSettingItem : NSObject/** 图标 */@property (nonatomic, strong) UIImage *image;/** 标题 */@property (nonatomic, copy) NSString *title;/** 子标题 */@property (nonatomic, copy) NSString *subTitle;/** 点击这行cell要做的事情 */@property (nonatomic, strong) void(^operation)(NSIndexPath *indexPath);+ (instancetype)itemWithImage:(UIImage *)image title:(NSString *)title;+ (instancetype)itemWithTitle:(NSString *)title;@end// SLSettingItem.m@implementation SLSettingItem+ (instancetype)itemWithImage:(UIImage *)image title:(NSString *)title{SLSettingItem *item = [[self alloc] init];item.image = image;item.title = title;return item;}+ (instancetype)itemWithTitle:(NSString *)title{return [self itemWithImage:nil title:title];}@end 箭头和开关cell12345678910111213// 带有箭头的cell是可以跳转狭义控制器的// 跳转目标控制器 1.绑定类名字符串 2.绑定类名// SLSettingArrowItem.h@interface SLSettingArrowItem : SLSettingItem/** 目标控制器类名 */@property (nonatomic, assign) Class desVc;@end// 带有开关的cell是要有开关状态的// SLSettingSwitchItem.m@interface SLSettingSwitchItem : SLSettingItem/** 状态 */@property (nonatomic, assign, getter=isOpen) BOOL open;@end 设置基础控制器SLBaseTableViewController 所有控制器都应使用UITableViewController且为组模式，结构基本相同，提取设置基础控制器 代码创建组类型，要重写init方法123- (instancetype)init{return [super initWithStyle:UITableViewStyleGrouped];} 基础控制器包含一个组数据（告诉控制器有多少组，且组中包含cell模型数组）1234@interface SLBaseTableViewController : UITableViewController/** 控制器的所有组 */@property (nonatomic, strong) NSMutableArray *groups;@end 数据源和代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {return self.groups.count;}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {// 取出组数组的当前组SLSettingGroup *group = self.groups[section];return group.items.count;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {SLSettingTableViewCell *cell = [SLSettingTableViewCell cellWithTableView:tableView];// 从总数组中取出组模型SLSettingGroup *group = self.groups[indexPath.section];// 从cell模型数组中取出当前cell模型SLSettingItem *item = group.items[indexPath.row];// 传递模型cell.item = item;return cell;}- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section{// 取出组模型SLSettingGroup *group = self.groups[section];return group.headerTitle;}- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection: (NSInteger)section {// 取出组模型SLSettingGroup *group = self.groups[section];return group.footTitle;}- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {[tableView deselectRowAtIndexPath:indexPath animated:YES];// 从总数组中取出组模型数组SLSettingGroup *group = self.groups[indexPath.section];// 从行模型数组中取出cell模型SLSettingItem *item = group.items[indexPath.row];if (item.operation) {item.operation(indexPath);}else if ([item isKindOfClass:[SLSettingArrowItem class]]) {// 只有剪头模型才具备跳转功能SLSettingArrowItem *arrowItem = (SLSettingArrowItem *)item;if (arrowItem.desVc) {// 如果有目标控制器// 拿到目标控制器类名 创建目标控制器UIViewController *vc = [[arrowItem.desVc alloc] init];vc.title = arrowItem.title;[self.navigationController pushViewController:vc animated:YES];}}} 设置控制器SLSettingTableViewController 添加模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)viewDidLoad {[super viewDidLoad];self.title = @&quot;设置&quot;;// 添加第0组[self setupGroup0];// 添加第1组[self setupGroup1];// 添加第2组// ...}/*** 第0组*/- (void)setupGroup0 {SLSettingArrowItem *item = [SLSettingArrowItem itemWithImage:[UIImage imageNamed:@&quot;RedeemCode&quot;] title:@&quot;使用兑换码&quot;];__weak typeof(self) weakSelf = self;// 使用item的operation跳转控制器item.operation = ^(NSIndexPath *indexPath) {UIViewController *vc = [[UIViewController alloc] init];vc.title = @&quot;asdf&quot;;vc.view.backgroundColor = [UIColor redColor];[weakSelf.navigationController pushViewController:vc animated:YES];};// 创建组模型SLSettingGroup *group = [SLSettingGroup groupWithItems:@[item]];group.headerTitle = @&quot;123&quot;;group.footTitle = @&quot;qeqrere&quot;;// 添加到总数组中[self.groups addObject:group];}/*** 第1组*/- (void)setupGroup1 {SLSettingArrowItem *item1 = [SLSettingArrowItem itemWithImage:[UIImage imageNamed:@&quot;MorePush&quot;] title:@&quot;推送和提醒&quot;];// 箭头特有属性desVc实现跳转item1.desVc = [SLPushTableViewController class];SLSettingSwitchItem *item2 = [SLSettingSwitchItem itemWithImage:[UIImage imageNamed:@&quot;handShake&quot;] title:@&quot;使用摇一摇机选&quot;];item2.open = YES;SLSettingSwitchItem *item3 = [SLSettingSwitchItem itemWithImage:[UIImage imageNamed:@&quot;sound_Effect&quot;] title:@&quot;声音效果&quot;];SLSettingSwitchItem *item4 = [SLSettingSwitchItem itemWithImage:[UIImage imageNamed:@&quot;More_LotteryRecommend&quot;] title:@&quot;购彩小助手&quot;];// 创建组模型SLSettingGroup *group = [SLSettingGroup groupWithItems:@[item1, item2, item3, item4]];group.headerTitle = @&quot;qwe&quot;;group.footTitle = @&quot;slll&quot;;// 添加到总数组中[self.groups addObject:group];}// ...// 添加... 其他的控制器与设置控制器相同，只需创建并添加相应的组模型 block简单介绍 封装一段代码，在合适的时候调用 两种定义方法（没有参数和返回值）12345678// 1. 第一种方法 这里的block是变量名void(^block)() = ^() {// 要保存的代码块...};// 2. 起别名的方式// 这里的MyBlock是类型名，这个可以跨方法执行typedef void(^MyBlock)();@property (nonatomic, strong) MyBlock block; block可以当做参数来传递 inline快速创建block 设置界面回顾 MVC设计模式的强大，更改需求只需修改模型，不需要再修改view的显示代码","link":"/2016/09/01/my-ios-day16/"},{"title":"my-ios-day17","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 17多线程 进程与线程 pthread NSThread GCD 进程与线程 进程 在系统中正在运行的一个应用程序。每个进程间是独立的，每个进程运行在专有且受保护的内存空间 是系统分配资源的基本单位 线程 一个进程要想执行任务，必须要有一个线程，线程执行任务是串行的，一个线程只能在执行一个任务 是系统程序调度的基本单位 多线程 一个进程可以开启多个线程，多条线程可以并行执行，同时执行 单核CPU的这种并行也是只有一条线程工作，只是CPU调度快，线程间不断切换 优点 能适当提高程序的执行效率 能适当提高资源（CPU、内存）利用率 缺点 开启线程会占用一定内存，开启过多线程会大量占用空间 线程越多，CPU调度线程的开销就越大 程序设计会过于复杂（进程间通信、资源共享） 是一种以空间换取时间的技术 pthread 简介 一套跨平台的多线程API（Unix、Linux、Windows等） 采用C语言，使用难度较大，很少使用 使用1234567891011// 创建线程对象pthread_t thread1;// 创建线程/*pthread_create(pthread_t *restrict, const pthread_attr_t *restrict, void *(*)(void *), void *restrict)第一个参数：线程对象、传递地址第二个参数：线程属性、NULL第三个参数：指向函数的指针第四个参数：函数需要接收的参数*/pthread_create(&amp;thread1, NULL, test, NULL); pthread 简介 三种创建方法12345678910111213141516171819202122232425// 通过init方法创建线程，需要手动开启/*initWithTarget:(nonnull id) selector:(nonnull SEL) object:(nullable id)第一个参数：目标对象、self第二个参数：方法选择器、调用的方法第三个参数：前面方法需要的参数、nil*/NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(test1) object:nil];// 开启线程[thread1 start];// 通过类方法创建，分离出的子线程/*detachNewThreadSelector:(nonnull SEL) toTarget:(nonnull id) withObject:(nullable id)第一个参数：方法选择器、调用的方法第二个参数：目标对象、self第三个参数：前面方法需要的参数、nil*/NSThread *thread2 = [NSThread detachNewThreadSelector:@selector(test2) toTarget:self withObject:nil];// 开启后台线程/*performSelectorInBackground:(nonnull SEL) withObject:(nullable id)第一个参数：方法选择器、调用的方法第二个参数：前面方法需要的参数、nil*/[self performSelectorInBackground:@selector(test3) withObject:nil]; 属性1234// 设置名字thread1.name = @&quot;线程1&quot;;// 线程优先级thread1.threadPriority = 1; 线程状态 新建状态 就绪状态 运行状态 阻塞状态1234// 第一种：阻塞两秒[NSThread sleepForTimeInterval:2.0];// 第二种：阻塞三秒[NSThread sleepUntilDate:[NSDate dateWithTimeInterval:3.0]]; 死亡状态12// 退出线程，退出后不能再重启线程[NSThread exit]; 线程安全 一块资源被多个线程访问，会引发数据混乱 加锁123456789101112// 锁是全局唯一的@synchronized(self) {NSInteger count = self.totalCount;if (count &gt; 0) {for (int i = 0; i &lt; 10000; i++) {}self.totalCount -= 1;}else {NSLog(@&quot;没有了&quot;);break;}} 注意： 加锁的位置 加锁的前提条件（多线程共享同一资源） 加锁是有代价的，需要耗费性能的 加锁的结果是：线程同步 原子和非原子 nonatomic和atomic atomic：线程安全，需要耗费大量资源，加锁 nonatomic：非线程安全，适合小内存移动设备 iOS注意 所有属性都声明为nonatomic 尽量避免多线程抢夺同一资源 将加锁、资源抢夺交给服务器，减小客户端压力 线程间通信 具体体现 一个线程传递数据给另一个线程 在一个特定线程执行完成过后，转到另一个线程继续执行任务 常用方法12345678910111213/*第一个参数：回到线程的什么方法第二个参数：回到那个线程第三个参数：传递的参数第四个参数：是否需要等待*/- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;/*第一个参数：回到主线程的什么方法第二个参数：传递的参数第三个参数：是否需要等待*/- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait; 图片下载 添加UIImageView 开启线程，下载图片 回到主线程刷新UI 代码123456789101112131415161718192021- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {[NSThread detachNewThreadSelector:@selector(downLoadImage) toTarget:self withObject:nil];}- (void)downLoadImage {NSLog(@&quot;%@&quot;, [NSThread currentThread]);CFTimeInterval startD = CFAbsoluteTimeGetCurrent();// 确定urlNSURL *url = [NSURL URLWithString:@&quot;http://www.onegreen.net/maps/Upload_maps/201412/2014120107143496.jpg&quot;];// 根据url下载图片到本地（二进制数据）NSData *imageData = [NSData dataWithContentsOfURL:url];// 转换数据UIImage *image = [UIImage imageWithData:imageData];// 回到主线程显示到imageView[self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];CFTimeInterval endD = CFAbsoluteTimeGetCurrent();NSLog(@&quot;%f&quot;, endD - startD);}- (void)showImage:(UIImage *)image {NSLog(@&quot;%@&quot;, [NSThread currentThread]);self.imageView.image = image;} 可以通过imageView调用回到主线程的方法1[self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; GCD 简介 Grand Centra Dispatch，纯C语言，拥有非常强大的函数 充分利用CPU多核，发挥设备性能 会自动管理线程的生命周期（创建、调度、销毁） 只需告诉GCD要执行的代码，不编写线程管理代码 两个核心概念 任务：需要执行的操作 队列：用来存放任务 两个步骤 定制任务，确定要执行的操作 添加到队列 GCD会自动取出队列中的任务，放到相应的线程执行 任务的取出遵守FIFO（先进先出）原则 两个函数 同步函数12345/*queue：队列block：任务*/dispatch_sync(dispatch_queue_t queue, ^(void)block) 异步函数12345/*queue：队列block：任务*/dispatch_async(dispatch_queue_t queue, ^(void)block) 区别 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新线程中执行任务，具备开启新线程的能力，但不一定开启新线程 两种队列 并发队列 可以让多个任务并发（同时）执行，自动开启多个线程同时执行任务 只有在异步函数dispatch_async中在有效（开线程） 串行队列 让任务一个接着一个的执行（一个任务执行完再执行下一个任务） 四种组合 异步函数+并发队列123456789101112131415161718192021222324252627282930/*** 异步函数+并发队列* 会开启多条线程，任务异步执行（没有顺序，一起执行）* 并不是有多少个任务就会开多少个线程*/- (void)asyncConcurrent {// 创建队列/*** label：C语言字符串，标签* queue：队列类型* DISPATCH_QUEUE_CONCURRENT：并发* DISPATCH_QUEUE_SERIAL：串行*/dispatch_queue_t queue = dispatch_queue_create(&quot;xyz.Sleen&quot;, DISPATCH_QUEUE_CONCURRENT);// 封装任务，添加到队列dispatch_async(queue, ^{NSLog(@&quot;downLoad - image1--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad - image2--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad - image3--%@&quot;, [NSThread currentThread]);});/* 打印结果downLoad - image1--&lt;NSThread: 0x7ff4a370ce40&gt;{number = 2, name = (null)}downLoad - image3--&lt;NSThread: 0x7ff4a3614ff0&gt;{number = 4, name = (null)}downLoad - image2--&lt;NSThread: 0x7ff4a347d260&gt;{number = 3, name = (null)}*/} 异步函数+串行队列1234567891011121314151617181920212223/*** 异步函数+串行队列* 会开启一条新线程，任务串行执行（一个接着一执行）*/- (void)asyncSerial {// 创建队列dispatch_queue_t queue = dispatch_queue_create(&quot;xyz.Sleen&quot;, DISPATCH_QUEUE_SERIAL);// 封装任务，添加到队列dispatch_async(queue, ^{NSLog(@&quot;downLoad - image1--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad - image2--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad - image3--%@&quot;, [NSThread currentThread]);});/* 打印结果downLoad - image1--&lt;NSThread: 0x7fe481e0ba00&gt;{number = 2, name = (null)}downLoad - image2--&lt;NSThread: 0x7fe481e0ba00&gt;{number = 2, name = (null)}downLoad - image3--&lt;NSThread: 0x7fe481e0ba00&gt;{number = 2, name = (null)}*/} 同步函数+并发队列1234567891011121314151617181920212223/*** 同步函数+并发队列* 不会开线程，任务串行执行（一个接着一执行）*/- (void)syncConcurrent {// 创建队列dispatch_queue_t queue = dispatch_queue_create(&quot;xyz.Sleen&quot;, DISPATCH_QUEUE_CONCURRENT);// 封装任务，添加到队列dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image1--%@&quot;, [NSThread currentThread]);});dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image2--%@&quot;, [NSThread currentThread]);});dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image3--%@&quot;, [NSThread currentThread]);});/* 打印结果：downLoad - image1--&lt;NSThread: 0x7fd3b2f00f50&gt;{number = 1, name = main}downLoad - image2--&lt;NSThread: 0x7fd3b2f00f50&gt;{number = 1, name = main}downLoad - image3--&lt;NSThread: 0x7fd3b2f00f50&gt;{number = 1, name = main}*/} 同步函数+串行队列1234567891011121314151617181920212223/*** 同步函数+串行队列* 不会开线程，任务串行执行（一个接着一执行）*/- (void)syncSerial {// 创建队列dispatch_queue_t queue = dispatch_queue_create(&quot;xyz.Sleen&quot;, DISPATCH_QUEUE_SERIAL);// 封装任务，添加到队列dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image1--%@&quot;, [NSThread currentThread]);});dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image2--%@&quot;, [NSThread currentThread]);});dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image3--%@&quot;, [NSThread currentThread]);});/* 打印结果：downLoad - image1--&lt;NSThread: 0x7fe333f04dd0&gt;{number = 1, name = main}downLoad - image2--&lt;NSThread: 0x7fe333f04dd0&gt;{number = 1, name = main}downLoad - image3--&lt;NSThread: 0x7fe333f04dd0&gt;{number = 1, name = main}*/} 涉及到同步函数的都不会创建新线程，任务都是串行执行 GCD提供一个全局并发队列123456/*** 获得全局并发队列* 第一个参数：优先级* 第二个参数：“未来使用”--0*/dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); GCD提供一个主队列（串行队列） 异步函数+主队列12345678910111213141516171819202122232425/*** 异步函数+主队列* 不会开线程，都在主线程中执行*/- (void)asycnMain {// 获取主线程dispatch_queue_t queue = dispatch_get_main_queue();// 封装任务，添加到队列dispatch_async(queue, ^{NSLog(@&quot;downLoad - image1--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad - image2--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad - image3--%@&quot;, [NSThread currentThread]);});/* 打印结果start---end---downLoad - image1--&lt;NSThread: 0x7fb533f01aa0&gt;{number = 1, name = main}downLoad - image2--&lt;NSThread: 0x7fb533f01aa0&gt;{number = 1, name = main}downLoad - image3--&lt;NSThread: 0x7fb533f01aa0&gt;{number = 1, name = main}*/} 同步函数+主队列1234567891011121314151617181920/*** 同步函数+主队列* 死锁*/- (void)sycnMain {// 获取主线程dispatch_queue_t queue = dispatch_get_main_queue();NSLog(@&quot;start---&quot;);// 封装任务，添加到队列dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image1--%@&quot;, [NSThread currentThread]);});dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image2--%@&quot;, [NSThread currentThread]);});dispatch_sync(queue, ^{NSLog(@&quot;downLoad - image3--%@&quot;, [NSThread currentThread]);});NSLog(@&quot;end---&quot;);} 死锁分析 主队列特点：如果主队列发现当前主线程正在执行任务，那么主队列会暂停调用队列中的任务，知道主线程空闲为止 同步函数+主队列，主线程正在执行sycnMain，因为接下来是同步函数，主线程不执行完sycnMain就不会继续执行，主队列就不会调用队列的任务，死锁 异步函数+主队列，主线程正在执行asycnMain，因为接下来是异步函数，可以等下回来在执行，主线程先执行完sycnMain，然后主队列再调用队列的任务，不会死锁 GCD线程间通信123456789101112131415161718dispatch_async(dispatch_get_global_queue(0, 0), ^{NSLog(@&quot;%@&quot;, [NSThread currentThread]);// 确定urlNSURL *url = [NSURL URLWitString:@&quot;http://www.onegreen.net/maps/Upload_maps/2014122014120107143496.jpg&quot;];// 根据url下载图片到本地（二进制数据）NSData *imageData = [NSData dataWihContentsOfURL:url];// 转换数据UIImage *image = [UIImage imageWthData:imageData];// 回到主线程显示到imageViewdispatch_async(dispatch_get_main_queue(), ^{NSLog(@&quot;%@&quot;, [NSThread currentThread]);self.imageView.image = image;});});/* 打印结果&lt;NSThread: 0x7ffa8861e9e0&gt;{number = 2, name = (null)}&lt;NSThread: 0x7ffa88404630&gt;{number = 1, name = main}*/ GCD其他方法 延迟执行1234567891011121314// 第一种：两秒执行self的test方法[self performSelector:@selector(test) withObject:self afterDelay:2];// 第二种：三秒后执行self的test方法，不重复[NSTimer timerWithTimeInterval:3 target:self selector:@selector(test) userInfo:nil repeats:NO];// 第三种：delayInSeconds秒后再主队列执行操作/*第一个参数：DISPATCH_TIME_NOW，从现在开始计算第二个参数：延迟的时间，GCD时间单位纳秒第三个参数：队列（主队列、串行队列、并发队列）block：操作*/dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{// code to be executed after a specified delay}); 一次性代码123456// 整个程序的运行过程中只会调用一次static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{// code to be executed onceNSLog(@&quot;--once--&quot;);}); 应用场景 —- 单例模式 栅栏函数 控制多线程异步执行顺序123456789101112131415161718192021dispatch_queue_t queue = dispatch_queue_create(&quot;sxy.Sleen&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);});dispatch_async(queue, ^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);});// 栅栏函数// 不能使用全局并发队列dispatch_barrier_async(queue, ^{NSLog(@&quot;-------栅栏函数&quot;);});dispatch_async(queue, ^{NSLog(@&quot;downLoad--3--%@&quot;, [NSThread currentThread]);});/*downLoad--1--&lt;NSThread: 0x7fad93c08760&gt;{number = 3, name = (null)}downLoad--2--&lt;NSThread: 0x7fad93e2b890&gt;{number = 2, name = (null)}-------栅栏函数downLoad--3--&lt;NSThread: 0x7fad93e2b890&gt;{number = 2, name = (null)}*/ 快速迭代 通过子线程和主线程并发执行123456789101112131415/*** 第一个参数：遍历的次数* 第二个参数：队列（只能是并发队列）* 第三个参数：索引*/dispatch_apply(5, dispatch_get_global_queue(0, 0), ^(size_t index) {NSLog(@&quot;%zu---%@&quot;, index, [NSThread currentThread]);});/*0---&lt;NSThread: 0x7fe83b629bb0&gt;{number = 2, name = (null)}1---&lt;NSThread: 0x7fe83b706490&gt;{number = 1, name = main}2---&lt;NSThread: 0x7fe83b517710&gt;{number = 3, name = (null)}3---&lt;NSThread: 0x7fe83b4115b0&gt;{number = 4, name = (null)}4---&lt;NSThread: 0x7fe83b629bb0&gt;{number = 2, name = (null)}*/ 队列组 用来管理队列，123456789101112131415161718192021222324252627282930313233343536- (void)group {// 创建队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);// 创建队列组dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);});dispatch_group_async(group, queue, ^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);});dispatch_group_async(group, queue, ^{NSLog(@&quot;downLoad--3--%@&quot;, [NSThread currentThread]);});// 拦截通知，队列组中的任务执行完毕后调用dispatch_group_notify(group, queue, ^{NSLog(@&quot;ALL--downLoad--&quot;);});// 等待，直到队列组所有任务完成后才向下执行dispatch_group_wait(group, DISPATCH_TIME_FOREVER);// 区别/* 异步函数* 1. 封装任务* 2. 添加任务到队列dispatch_async(queue, ^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);});* 队列组* 1. 封装任务* 2. 添加任务到队列* 3. 监听任务的执行情况，通知groupdispatch_group_async(group, queue, ^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);});*/}","link":"/2016/09/01/my-ios-day17/"},{"title":"my-ios-day19","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ Day 19网络 相关概念 NSURLConnection 数据解析 NSURLConnection文件传输 NSURLSession AFNetworking 相关概念 基础 客户端，手机所使用的app 服务器，远程服务器(Linux系列，windows) 请求，客户端向服务器索取数据的方式 响应，服务器返回、客户端需要解析的数据 统一资源定位符URL 定位主机和资源 格式（协议/主机地址/资源路径） 协议：资源的查找方式和传输方式（HTTP、FTP…） 主机地址：存放资源的服务器主机的IP地址、域名 路径：资源在服务器主机中的位置 常见协议 file：本地计算机的资源，file:// ftp：共享主机的资源，ftp:// mailto：电子邮件地址，mailto: http：超文本传输协议，访问远程的网络资源，http:// http协议 简介 超文本传输协议 规定客户端和服务器之间数据传输格式 让客户端和服务器有效的进行数据沟通 请求通信过程 请求请求头 + 请求体(非必须) 响应响应头 + 响应体 通信过程客户端发送请求时，先把请求头和请求体（非必须）封装成一个请求对象服务器端对请求进行响应，在响应信息中包含响应头和响应体，响应信息是对服务器端的描述，具体的信息放在响应体中传递给客户端 常见状态码200：请求成功400：请求语法错误，服务器无法解析404：资源路径不存在500：服务器内部错误 请求 GET请求http://www.test.com/login?username=123&amp;pwd=234请求的参数跟在URL的后面，以?隔开，使用&amp;连接服务器对URL的长度有限制，所以对参数长度有限制，通常不超过1KB POST请求http://www.test.com/login请求的参数放在请求体里面，POST的数据量一般无限制，主要看服务器 如何选择如果有大量数据传输，上传、下载等，只能使用POSTGET中的参数过于暴露，设计敏感、机密需要用POST增加、修改、删除数据，建议使用POST只有在简单的查询数据，使用GET iOS中的请求 系统原生 NSURLConnection 03年的古老技术 NSURLSession 13年iOS7之后推出，替代NSURLConnection CFNetwork 底层所依赖的技术，纯C 第三方框架 ASIHttpRequest 已不再维护 AFNetworking 主流 NSURLConnection 同步请求GET-sync123456789101112- (void)syncG {// 确定URLNSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON&quot;];// 封装请求NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];// 声明响应NSURLResponse *reponse = nil;// 发送请求，接收数据NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;reponse error:nil];// 简单打印NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);} 异步请求GET-async1234567891011121314- (void)asyncG {// 确定URLNSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON&quot;];// 封装请求NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];// 发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {// 简单打印数据NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);// 响应头信息NSHTTPURLResponse *re = (NSHTTPURLResponse *)response;NSLog(@&quot;%ld&quot;, re.statusCode);}];} 异步请求GET-delegate123456789101112131415161718192021222324252627282930313233343536373839404142- (void)delegateG {// 确定URLNSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/video?type=JSON&quot;];// 封装请求NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];// 设置代理// [NSURLConnection connectionWithRequest:request delegate:self];// [[NSURLConnection alloc] initWithRequest:request delegate:self];NSURLConnection *con = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];// 可以特定时间开始发送请求[con start];[con cancel];}#pragma mark - NSURLConnectionDataDelegate/*** 接收服务器响应时调用*/- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {NSLog(@&quot;%s&quot;, __func__);}/*** 接收到服务器返回数据时调用* 可能会带哦与功能多次*/- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {NSLog(@&quot;%s&quot;, __func__);[self.allData appendData:data];}/*** 请求失败会调用*/- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {NSLog(@&quot;%s&quot;, __func__);}/*** 请求结束时会调用*/- (void)connectionDidFinishLoading:(NSURLConnection *)connection {NSLog(@&quot;%s&quot;, __func__);NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:self.allData encoding:NSUTF8StringEncoding]);} POST请求 步骤 确定URL 创建可变的请求对象 修改请求对象的方法为POST 设置请求体 发送异步请求 设置超时，处理错误信息，设置请求头（可选） 代码12345678910111213- (void)asyncP {NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];// 修改请求类型，POST必须大写request.HTTPMethod = @&quot;POST&quot;;// 设置请求体信息NSData *bodyData = [@&quot;username=52it&amp;pwd=520it&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding];request.HTTPBody = bodyData;// 发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);}];} 数据解析 常用数据格式 JSON：轻量级，比较流行 XML：可拓展标记语言，包含声明、元素和属性 JSON解析 NSJSONSerialization JSON–&gt;OC （反序列化）12345678910111213141516- (void)JOSNToOC {NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=123&amp;pwd=123&amp;type=JSON&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:url];[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {/*第一个参数：要解析的JSON数据，NSData，二进制数据第二个参数：解析JSON的配置参数（可选）NSJSONReadingMutableContainers 解析出来的字典和数组是可变的NSJSONReadingMutableLeaves 解析出来的对象中的字符串是可变的 iOS7以后有问题，不用NSJSONReadingAllowFragments 被解析的JSON数据如果既不是字典也不是数组， 那么就必须使用这个kNilOptions == 0 哪个也不选，高效*/NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil];NSLog(@&quot;%@&quot;,dict);}];} OC–&gt;JSON （序列化）12345678910111213141516171819202122/*OC--&gt;JSON有一定限制使用+ (BOOL)isValidJSONObject:(id)obj;方法判断当前OC对象能否转换为JSON数据1. obj是NSArray或NSDictionary以及他们的子类2. obj包含的所有对象是NSString、NSNumber、NSArray、NSDictionary、NSNull3. 字典中的所有key必须是NSString4. NSNumber的对象不能是Nan或无穷大*/// 需要序列化的数据NSDictionary *dictM = @{@&quot;name&quot;:@&quot;sleen&quot;,@&quot;age&quot;:@18,@&quot;height&quot;:@1.80};/*第一个参数：需要序列化的数据第二个参数：NSJSONWritingPrettyPrinted对转换之后的JSON对象进行排版，无意义*/NSData *data = [NSJSONSerialization dataWithJSONObject:dictM options:NSJSONWritingPrettyPrinted error:nil];// 查看是否序列化NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];NSLog(@&quot;%@&quot;,str); JSON数据与OC对象对应{} –&gt; NADictionary[] –&gt; NSArray“” –&gt; NSString10/10.1 –&gt; NSNumbertrue/false –&gt; NSNumbernull –&gt; NSNull XML解析 两种方式 SAX：从根节点开始，按顺序一个元素一个元素的向下解析 DOM：一次性将整个xml文档加载到内存中，使用与较小文件 工具 NSXMLParser：苹果原生，采用SAX，使用简单 libxml2：纯C，默认在iOS SDK中，同时支持SAX和DOM GDataXML：Google的基于libxml2，采用DOM方式 NSXMLParser12345678910111213141516171819202122232425// 创建一个解析器NSXMLParser *parser = [[NSXMLParser alloc]initWithData:data];// 设置代理parser.delegate = self;// 开始解析[parser parse];// 开始解析XML文档- (void)parserDidStartDocument:(nonnull NSXMLParser *)parser {}// 开始解析XML中某个元素的时候调用，比如&lt;video&gt;- (void)parser:(nonnull NSXMLParser *)parser didStartElement:(nonnull NSString *)elementName namespaceURI:(nullable NSString *)namespaceURI qualifiedName:(nullable NSString *)qName attributes:(nonnull NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict{if ([elementName isEqualToString:@&quot;videos&quot;]) {return;}// 字典转模型SLVideo *video = [SLVideo objectWithKeyValues:attributeDict];[self.videos addObject:video];}// 当某个元素解析完成之后调用，比如&lt;/video&gt;- (void)parser:(nonnull NSXMLParser *)parser didEndElement:(nonnull NSString *)elementName namespaceURI:(nullable NSString *)namespaceURI qualifiedName:(nullable NSString *)qName {}// XML文档解析结束- (void)parserDidEndDocument:(nonnull NSXMLParser *)parser {} 文件传输 小文件下载 直接下载，无多线程1234567// 确定资源路径NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_01.png&quot;];// 根据URL加载对应的资源NSData *data = [NSData dataWithContentsOfURL:url];// 转换并显示数据UIImage *image = [UIImage imageWithData:data];self.imageView.image = image; NSURLConnection - sendAsync12345678910// 确定请求路径NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_01.png&quot;];// 创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 使用NSURLConnection发送一个异步请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {// 设置数据UIImage *image = [UIImage imageWithData:data];self.imageView.image = image;}]; NSURLConnection - delegate1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)delegateDownload {// 确定请求路径NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;];//2.创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];//3.使用NSURLConnection设置代理并发送异步请求[NSURLConnection connectionWithRequest:request delegate:self];}#pragma mark - NSURLConnectionDataDelegate// 当接收到服务器响应的时候调用，该方法只会调用一次- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {// 创建一个容器，用来接收服务器返回的数据self.fileData = [NSMutableData data];// 获得当前要下载文件的总大小（通过响应头得到）NSHTTPURLResponse *res = (NSHTTPURLResponse *)response;self.totalLength = res.expectedContentLength;// 拿到服务器端推荐的文件名称self.fileName = res.suggestedFilename;}// 当接收到服务器返回的数据时会调用// 该方法可能会被调用多次- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {// 拼接每次下载的数据[self.fileData appendData:data];// 计算当前下载进度并刷新UI显示self.currentLength = self.fileData.length;NSLog(@&quot;%f&quot;,1.0* self.currentLength/self.totalLength);self.progressView.progress = 1.0* self.currentLength/self.totalLength;}//当网络请求结束之后调用- (void)connectionDidFinishLoading:(NSURLConnection *)connection {// 文件下载完毕把接受到的文件数据写入到沙盒中保存// 确定要保存文件的全路径// caches文件夹路径NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSString *fullPath = [caches stringByAppendingPathComponent:self.fileName];// 写数据到文件中[self.fileData writeToFile:fullPath atomically:YES];}// 当请求失败的时候调用该方法- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {NSLog(@&quot;%s&quot;,__func__);} 大文件下载 文件句柄下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark - NSURLConnectionDataDelegate- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {// 当已经下载过，就不在创建文件if (self.currentSize &gt; 0) {return ;}// 获取文件总大小NSHTTPURLResponse *res = (NSHTTPURLResponse *)response;self.totalSize = res.expectedContentLength;// 创建一个新的文件// 得到文件管理者NSFileManager *man = [NSFileManager defaultManager];// 搜索cache路径NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];// 拼接全路径NSString *path = [caches stringByAppendingPathComponent:res.suggestedFilename];self.fullPath = path;// 创建文件/** 第一个参数：文件路径* 第二个参数：文件内容* 第三个参数：文件属性*/[man createFileAtPath:path contents:nil attributes:nil];}- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {// 文件句柄self.handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath];// 移动句柄[self.handle seekToEndOfFile];// 追加数据[self.handle writeData:data];// 得到已下载大小self.currentSize += data.length;self.progressV.progress = 1.0 * self.currentSize / self.totalSize;self.progressL.text = [NSString stringWithFormat:@&quot;%.2f&quot;, self.progressV.progress];NSLog(@&quot;%f&quot;, self.progressV.progress);}- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {}- (void)connectionDidFinishLoading:(NSURLConnection *)connection {[self.handle closeFile];self.handle = nil;NSLog(@&quot;%s&quot;, __func__);NSLog(@&quot;%@&quot;, self.fullPath);} 输出流下载123456789101112131415161718192021// 创建一个数据输出流/** 第一个参数：二进制的流数据要写入到哪里* 第二个参数：采用什么样的方式写入流数据，如果YES则表示追加，如果是NO则表示覆盖*/NSOutputStream *stream = [NSOutputStream outputStreamToFileAtPath:fullPath append:YES];// 只要调用了该方法就会往文件中写数据// 如果文件不存在，那么会自动的创建一个[stream open];self.stream = stream;// 当接收到数据的时候写数据// 使用输出流写数据/*第一个参数：要写入的二进制数据第二个参数：要写入的数据的大小*/[self.stream write:data.bytes maxLength:data.length];// 当文件下载完毕的时候关闭输出流// 关闭输出流[self.stream close];self.stream = nil; 文件上传 步骤 确定请求的URL 创建可变的请求对象 修改请求方式为POST 设置请求头，通知服务器将要上传文件Content-Type 设置请求体（严格按确定格式拼接数据） 发送异步请求上传文件 解析服务器返回数据 请求体数据格式123456789101112分隔符：----WebKitFormBoundaryhBDKBUvFdCAgsr5b格式：--分隔符Content-Dispostion:参数Content-Type:参数空行文件参数--分隔符Content-Disposition:参数空行非文件的二进制数据--分隔符-- 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#define Kboundary @“----WebKitFormBoundaryhBDKBUvFdCAgsr5b”- (void)upload{// 1.确定请求路径NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/upload&quot;];// 2.创建一个可变的请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 3.设置请求方式为POSTrequest.HTTPMethod = @&quot;POST&quot;;// 4.设置请求头NSString *filed = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,Kboundary];[request setValue:filed forHTTPHeaderField:@&quot;Content-Type&quot;];// 5.设置请求体NSMutableData *data = [NSMutableData data];// 5.1 文件参数/*--分隔符Content-Disposition:参数Content-Type:参数空行文件参数*/[data appendData:[[NSString stringWithFormat:@&quot;--%@&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine];[data appendData:[@&quot;Content-Disposition: form-data; name=\\&quot;file\\&quot;; filename=\\&quot;test.png\\&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine];[data appendData:[@&quot;Content-Type: image/png&quot; dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine];[data appendData:KnewLine];[data appendData:KnewLine];UIImage *image = [UIImage imageNamed:@&quot;test&quot;];NSData *imageData = UIImagePNGRepresentation(image);[data appendData:imageData];[data appendData:KnewLine];// 5.2 非文件参数/*--分隔符Content-Disposition:参数空行非文件参数的二进制数据*/[data appendData:[[NSString stringWithFormat:@&quot;--%@&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine];[data appendData:[@&quot;Content-Disposition: form-data; name=\\&quot;username\\&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine];[data appendData:KnewLine];[data appendData:KnewLine];NSData *nameData = [@&quot;wendingding&quot; dataUsingEncoding:NSUTF8StringEncoding];[data appendData:nameData];[data appendData:KnewLine];// 5.3 结尾标识// --分隔符--[data appendData:[[NSString stringWithFormat:@&quot;--%@--&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine];request.HTTPBody = data;// 6.发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) {// 7.解析服务器返回的数据NSLog(@&quot;%@&quot;,[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);}];} 获取文件的MIMEType类型12345678910111213- (NSString *)getMIMEType{NSString *filePath = @&quot;/Users/xiuxiu/Desktop/sleen.txt&quot;;// 同步请求获取NSURLResponse *response = nil;[NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:filePath]] returningResponse:&amp;response error:nil];// 异步请求获取[NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:@&quot;/Users/xiuxiu/Desktop/sleen.png&quot;]] queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) {// response.MIMETypeNSLog(@&quot;%@&quot;,response.MIMEType);}];return response.MIMEType;} NSURLSession 使用 通过NSURLSession创建task，执行task NSURLSessionTask 本身是一个抽象类，使用三个子类 NSURLSessionDataTask NSURLSessionUploadTask NSURLSessionDownloadTask 发送请求 GET请求123456789101112131415161718// block方式- (void)get {// 创建session，获得单例/自定义NSURLSession *session = [NSURLSession sharedSession];// 创建请求对象NSURL *url = [NSURL URLWithString:@&quot;&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:url];// 根据session创建taskNSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {// 解析数据}];// GET请求可以直接使用url创建// NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {// // 解析数据// }];// 执行task[task resume];} POST请求12345678910111213141516- (void)post {// 创建session，获得单例/自定义NSURLSession *session = [NSURLSession sharedSession];// 创建请求对象NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 设置请求request.HTTPMethod = @&quot;POST&quot;;request.HTTPBody = [@&quot;username=123&amp;pwd=123&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding];// 根据session创建taskNSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {// 解析数据}];// 执行task[task resume];} 文件传输 文件下载12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)download {// 代理方式需要使用自定义的sessionNSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 创建请求对象NSURL *url = [NSURL URLWithString:@&quot;&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:url];// 根据session创建taskNSURLSessionDataTask *task = [session dataTaskWithRequest:request];// 执行task[task resume];}#pragma mark - NSURLSessionDataDelegate/*** 收到服务器响应时调用** @param session 发送请求的session对象* @param dataTask 创建的task任务* @param response 响应信息（响应头）* @param completionHandler 回调，是否要接收数据*/- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {// 默认情况下，当接收到服务器响应之后，服务器认为客户端不需要接收数据，所以后面的代理方法不会调用// 如果需要继续接收服务器返回的数据，那么需要调用block，并传入对应的策略/*NSURLSessionResponseCancel = 0, 取消任务NSURLSessionResponseAllow = 1, 接收任务NSURLSessionResponseBecomeDownload = 2, 转变成下载NSURLSessionResponseBecomeStream NS_ENUM_AVAILABLE(10_11, 9_0) = 3, 转变成流*/completionHandler(NSURLSessionResponseAllow);}/*** 收到服务器返回数据是调用* 方法会被调用多次*/- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {}/*** 请求完成后会调用* 成功和失败都会调用，失败后error会保存失败信息*/- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {} 大文件下载（离线缓存）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#pragma mark - lazy- (NSString *)fullPath {if (_fullPath == nil) {NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];_fullPath = [path stringByAppendingPathComponent:Filename];}return _fullPath;}- (NSURLSession *)session {if (!_session) {// 代理方式需要使用自定义的session_session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];}return _session;}- (NSURLSessionDataTask *)task {if (!_task) {// 创建请求对象NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;];NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];// 设置请求头self.currentSize = [self oldFileSize];NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;, self.currentSize];[request setValue:range forHTTPHeaderField:@&quot;range&quot;];// 创建人物_task = [self.session dataTaskWithRequest:request];}return _task;}#pragma mark - other/*** 获取本地文件大小*/- (NSInteger)oldFileSize {NSDictionary *fileInfo = [[NSFileManager defaultManager] attributesOfItemAtPath:self.fullPath error:nil];return [fileInfo[@&quot;NSFileSize&quot;] integerValue];}#pragma mark - NSURLSessionDataDelegate- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {self.totalSize = response.expectedContentLength + self.currentSize;if (self.currentSize == 0) {[[NSFileManager defaultManager] createFileAtPath:self.fullPath contents:nil attributes:nil];}self.handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath];completionHandler(NSURLSessionResponseAllow);}- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {[self.handle seekToEndOfFile];[self.handle writeData:data];self.currentSize += data.length;self.progressV.progress = 1.0 * self.currentSize / self.totalSize;self.progressL.text = [NSString stringWithFormat:@&quot;%.2f&quot;, self.progressV.progress];}- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {[self.handle closeFile];self.handle = nil;NSLog(@&quot;didCompleteWithError%@&quot;, error);NSLog(@&quot;%@&quot;, self.fullPath);} 文件上传1234567891011121314151617- (void)upload {NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/upload&quot;];NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];request.HTTPMethod = @&quot;POST&quot;;[request setValue:[NSString stringWithFormat:@&quot;multipart/form-data;boundary=%@&quot;, Kboundary] forHTTPHeaderField:@&quot;Content-Type&quot;];NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];NSURLSessionUploadTask *task = [session uploadTaskWithRequest:request fromData:[self getBodyData] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);}];[task resume];}- (NSData *)getBodyData {// 拼接数据}- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {NSLog(@&quot;%f&quot;,1.0 *totalBytesSent / totalBytesExpectedToSend);} AFNetworking","link":"/2016/09/01/my-ios-day19/"},{"title":"my-ios-day18","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ Day 18多线程 单例模式 NSOperation 多图下载 SDWebImage框架 NSCache 位移枚举 RunLoop 单例模式 简介 整个程序运行中，一个类只有一个实例，且易于外界访问 方便控制实例个数，节约资源 使用场景 整个应用共享一份资源，只需要初始化一次 实现 新建一个类SLPerson1234567891011121314151617181920212223242526272829303132333435@interface SLPerson : NSObject/*** 返回person单例*/+ (instancetype)sharePerson;@end@implementation SLPersonstatic SLPerson *_person;+ (instancetype)allocWithZone:(struct _NSZone *)zone {// 懒加载// @synchronized(self) {// if (_person == nil) {// _person = [super allocWithZone:zone];// }// }// 一次性代码static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{_person = [super allocWithZone:zone];});return _person;}+ (instancetype)sharePerson {return [[SLPerson alloc] init];}- (id)copyWithZone:(NSZone *)zone {return _person;}- (id)mutableCopyWithZone:(NSZone *)zone {return _person;}@end NSOperation 简介 基于GCD 两个概念：队列和操作 使用 NSOperation是一个抽象类，要使用其子类 可以使用的三个子类：NSBlockOperation、NSInvocationOperation和自定义继承自NSOperation的类 NSOperation和NSOperationQueue需要结合使用 代码 NSInvocationOperation12345678/*第一个参数：目标对象第二个参数：该操作要调用的方法第三个参数：调用方法传递的参数*/NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];// 启动操作[operation start]; NSBlockOperation123456789NSBlockOperation *ope1 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *ope2 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);}];// 启动操作[ope1 start];[ope2 start]; NSOperationQueue的使用 两种队列 主队列，通过mainQueue获得，放在主队列的操作都在主线程中执行 非主队列，使用alloc init得到的队列，具有并发和串行的功能，通过设置最大并发数属性来控制操作是并发还是串行 代码1234567891011121314151617181920212223242526272829303132333435363738394041/*invocation和非主队列会开子线程，实现并发操作*/- (void)invocationWithQueue {// 创建操作NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run1) object:nil];NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run2) object:nil];NSInvocationOperation *op3 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run3) object:nil];// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加操作到队列// 内部会调用[op start];[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3];}/*block和非主队列会开子线程，操作并发*/- (void)blockWithQueue {NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--3--%@&quot;, [NSThread currentThread]);}];// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加操作到队列// 内部会调用[op start];[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3];// 有快速的创建方法// [queue addOperationWithBlock^{}];} 自定义SLOperation : NSOperation 代码1234567891011121314151617- (void)customWithQueue {// 创建操作SLOperation *op1 = [[SLOperation alloc] init];SLOperation *op2 = [[SLOperation alloc] init];// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加操作到队列[queue addOperation:op1];[queue addOperation:op2];}// SLOperation.m@implemetation SLOperation// 重写mian方法，设置操作- (void)main {NSLog(@&quot;downLoad---&quot;);}@end 使用 有利于代码的隐蔽性 提高代码的复用性 NSOperation的一些功能 最大并发数12345678910111213// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 设置最大并发数：同一时间最多有多少个操作执行，默认不受限制的queue.maxConcurrentOperationCount = 5;// 可以将默认的并发设置为串行// 串行并不是只开一条线程，而是线程同步// queue.maxConcurrentOperationCount = 1;// 创建操作SLOperation *op1 = [[SLOperation alloc] init];SLOperation *op2 = [[SLOperation alloc] init];// 添加操作到队列[queue addOperation:op1];[queue addOperation:op2]; 暂停恢复和取消 暂停恢复12// 设置队列的暂停 YES、恢复 NO@property (getter=isSuspended) BOOL suspended; 取消1234567// 取消执行队列中的所有任务- (void)cancelAllOperations;// 在自定义的Operation中// 苹果官方建议，每当执行完一次耗时操作之后，就查看一下当前操作是否为取消状态，如果是，那么就直接退出，可以用户体验if (self.isCancelled) {return;} 操作依赖和监听 依赖123456789101112131415161718NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--3--%@&quot;, [NSThread currentThread]);}];// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加依赖// op1依赖于op2，只有op2完成才能执行op1[op1 addDependency:op2];// 添加操作到队列[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3]; 监听12345678910111213141516171819NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--1--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--2--%@&quot;, [NSThread currentThread]);}];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{NSLog(@&quot;downLoad--3--%@&quot;, [NSThread currentThread]);}];// 监听操作op3.completionBlock = ^{NSLog(@&quot;op3 完成&quot;);};// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加操作到队列[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3]; NSOperation线程间通信123456789101112131415// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];// 使用简便方法封装操作并添加到队列中[queue addOperationWithBlock:^{// 在该block中下载图片NSURL *url = [NSURL URLWithString:@&quot;http://news.51sheyuan.com/uploads/allimg/111001/133442IB-2.jpg&quot;];NSData *data = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:data];NSLog(@&quot;下载图片操作--%@&quot;,[NSThread currentThread]);// 回到主线程刷新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^{self.imageView.image = image;NSLog(@&quot;刷新UI操作---%@&quot;,[NSThread currentThread]);}];}]; 多图下载 简要代码12345678SLApp *app = self.apps[indexPath.row];cell.textLabel.text = app.name;cell.detailTextLabel.text = app.download;NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:app.icon]];UIImage *image = [UIImage imageWithData:data];cell.imageView.image = image;return cell; 涉及问题 UI卡顿 图片多次下载 解决 图片多次下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 使用内存缓存// 去内存缓存找图片UIImage *image = [self.images objectForKey:app.name];if (image == nil) {// 如果没有就去下载NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:app.icon]];UIImage *image = [UIImage imageWithData:data];cell.imageView.image = image;// 添加图片到内存缓存[self.images setObject:image forKey:app.name];}else {cell.imageView.image = image;}// 使用磁盘缓存/*Documents：会备份，Libray：Preferences：偏好设置，账号属性Caches：缓存文件tmp：临时文件，随时会被删除*/// 去内存缓存找图片UIImage *image = [self.images objectForKey:app.name];if (image == nil) {// 获取缓存路径NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];// 拼接图片全路径NSString *fileName = [app.icon lastPathComponent];NSString *imagePath = [path stringByAppendingPathComponent:fileName];// 内存中没有// 1. 先检查磁盘缓存NSData *imageData = [NSData dataWithContentsOfFile:imagePath];if (imageData == nil) {// 2. 如果没有就去下载，保存到内存和沙盒NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:app.icon]];UIImage *image = [UIImage imageWithData:data];cell.imageView.image = image;// 添加图片到内存缓存[self.images setObject:image forKey:app.name];// 添加图片到磁盘缓存// 写数据打沙盒[data writeToFile:imagePath atomically:YES];}UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;}else {cell.imageView.image = image;}return cell; UI的流畅性 开线程下载图片123456789101112131415if (imageData == nil) {// 2. 如果没有就去下载，保存到内存和沙盒[self.queue addOperationWithBlock:^{NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:app.icon]];UIImage *image = [UIImage imageWithData:data];// 添加图片到内存缓存[self.images setObject:image forKey:app.name];// 添加图片到磁盘缓存[data writeToFile:imagePath atomically:YES];// 回到主线程刷新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^{cell.imageView.image = image;}];}];} 图片不会刷新 图片已经下载，但是应为frame问题不会显示，主动刷新12345// 刷新tableView的一行[[NSOperationQueue mainQueue] addOperationWithBlock:^{[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];// cell.imageView.image = image;}]; 滑动过快，图片下载需要时间，图片下载操作反复添加 操作缓存1[self.operation setObject:[[self.queue operations] lastObject] forKey:app.icon]; 总结 主要关注点 缓存的处理，NSDictionary使用 存储数据到沙盒 占位图片的处理 程序并发时，差错控制 cell重用的数据错乱处理 NSOperation的使用 主要逻辑 在本地磁盘查找缓存，如果存在直接显示 磁盘中没有查看内存缓存，如有直接显示，并保存到磁盘 如果内存没有，创建NSOperation下载操作，添加到NSOperationQueue中 下载操作中，图片下载完毕，需要保存到内存和磁盘缓存 对url进行容错处理，下载不成功要重新下载 添加操作到操作缓存，避免操作多次添加，图片多次下载 图片下载完成回到主线程，要立即刷新当前行 在最开始为imageView设置占位图片 SDWebImage 简介 使用 方法1234567891011121314151617/*第一个参数：下载图片的url第二个参数：占位图片第三个参数：枚举值，下载图片的策略回调参数receivedSize：已经下载完成的数据大小expectedSize：该文件的总大小image：下载得到的图片数据error：下载的错误信息SDImageCacheType：图片的缓存策略imageURL：下载图片的url*/[cell.imageView sd_setImageWithURL:(NSURL *) placeholderImage:(UIImage *) options:(SDWebImageOptions) progress:^(NSInteger receivedSize, NSInteger expectedSize) {NSLog(@&quot;%f&quot;, 1.0 * receivedSize / expectedSize);} completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {NSLog(@&quot;%@&quot;, image);}]; 内存 一些细节 开子线程的最大并发数12345// 默认是6_downloadQueue.maxConcurrentOperationCount = 6;- (NSInteger)maxConcurrentDownloads {return _downloadQueue.maxConcurrentOperationCount;} 缓存文件的路径和名称12名称是URL的MD5加密Cache--&gt;default--&gt;*ache--&gt;图片 内部内存管理123456789101112131415// 通过监听通知的方式，来清理的[[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(clearMemory)name:UIApplicationDidReceiveMemoryWarningNotificationobject:nil];[[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(cleanDisk)name:UIApplicationWillTerminateNotificationobject:nil];[[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(backgroundCleanDisk)name:UIApplicationDidEnterBackgroundNotificationobject:nil]; 内部缓存方法1类似于NSMutableDictionary的 ---&gt; NSCache 图片类别的判断12// 内部主要根据图片十六进制的第一个字节+ (NSString *)sd_contentTypeForImageData:(NSData *)data; 图片下载方法12NSURLConnection ----&gt; 建立网络请求连接建立连接后通过代理来下载图片 内部逻辑结构12345678// UIButton+WebCache- (void)sd_setBackgroundImageWithURL:(NSURL *)url forState:(UIControlState)state placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options completed:(SDWebImageCompletionBlock)completedBlock;// SDWebImageManager- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;// SDWebImageDownloader- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock// SDWebImageDownloaderOperation- (id)initWithRequest:(NSURLRequest *)request options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock cancelled:(SDWebImageNoParamsBlock)cancelBlock; NSCache 简介 苹果官方的缓存处理类，与字典类似 内存很低会自动释放对象 线程安全的，不需要加锁 对象的强引用，不是拷贝 属性 name：名称 delegate：设置代理 totalCostLimit：缓存空间的总成本，超出会回收，默认0没限制 evictsObjectsWithDiscardedContent：标识缓存是否回收废弃内容 使用12345678// 添加缓存- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost：成本- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;// 拿到缓存- (nullable ObjectType)objectForKey:(KeyType)key;// 删除缓存- (void)removeObjectForKey:(KeyType)key;- (void)removeAllObjects; 位移枚举 枚举 第一种12345typedef enum{SLTypeOne,SLTypeTwo}SLType; 第二种，可以定义类型12345typedef NS_ENUM(NSInteger, SLType){SLTypeOne,SLTypeTwo}; 第三种，位移枚举1234567typedef NS_OPTIONS(NSInteger, SLNewType){SLTypeOne = 1 &lt;&lt; 0, // 1SLTypeTwo = 1 &lt;&lt; 1, // 2SLTypeThree = 1 &lt;&lt; 2, // 4SLTypeFour = 1 &lt;&lt; 3 // 8} 用途：多个量传递1234567891011121314151617181920// 按位或 |// objc.type = 0011obj.type = SLTypeOne | SLTypeTwo;// 按位与 &amp;// 0011 &amp; 0001 = 1if(obj.type &amp; SLTypeOne) {NSLog(@&quot;SLTypeOne&quot;);}// 0011 &amp; 0010 = 1if(obj.type &amp; SLTypeTwo) {NSLog(@&quot;SLTypeTwo&quot;);}// 0011 &amp; 0100 = 0if(obj.type &amp; SLTypeThree) {NSLog(@&quot;SLTypeThree&quot;);}// 0011 &amp; 1000 = 0if(obj.type &amp; SLTypeFour) {NSLog(@&quot;SLTypeFour&quot;);} RunLoop 简介 运行循环，保持程序的持续运行 处理App中的各种事件（触摸、定时器、Selector） 节省CPU资源，提高性能，有事就做，没事休息 两套API访问RunLoop Foundation–&gt;NSRunLoop Core Foundation–&gt;CFRunLoopRef RunLoop与线程 每条线程都有唯一的一个RunLoop对象 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建 RunLoop在第一次获取是创建，在线程结束时销毁 获得RunLoop对象 Foundation12[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation12CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 Core Foundation 中的五个类 CFRunLoopRef CFrunLoopModeRef 运行模式 CFRunLoopSourceRef 事件源输入源 CFRunLoopTimerRef 定时器事件 CFRunLoopObserveRef 监听运行 RunLoop运行 RunLoop有多个运行模式，但它只能在一种模式运行 Mode中至少要一个Source或Timer，Observe可选 每次RunLoop启动，只能指定一个Mode（currentMode） 如果需要切换Mode，只能退出Loop，在指定新的Mode 系统默认五种运行模式 kCFRunLoopDefaultMode：app的默认模式，通常主线程在这个模式下运行 UITrackingRunLoopMode：界面跟踪Mode，用于ScrollView追踪滑动触摸，保证界面滑动不受其他Mode影响 UIInitializationRunLoopMode：在刚启动App时进入的第一个Mode，启动完就不在使用 GSEventReceiveRunLoopMode：接收系统事件的内部Mode，通常不用 kCFRunLoopCommonModes：这是一个占位用的Mode，不是真的Mode 事件源（输入源）分类 官方文档 Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources 函数调用栈 Source0：非基于Port的 Source1：基于Port的 监听者Observer 监听RunLoop的状态改变 步骤12345678// 创建一个监听者对象CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {NSLog(@&quot;监听runloop状态改变---%zd&quot;,activity);});// 添加监听者CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);// 移除监听者CFRelease(observer); 几个RunLoop状态123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入RunloopkCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理NSTimerkCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理SourceskCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出runloopkCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变}; RunLoop的运行逻辑 事件队列 每次运行RunLoop，会自动处理之前未处理的消息，并通知相关的监听者 具体过程 通知监听者RunLoop已经启动 通知监听者任何即将开始的定时器 通知监听者任何即将启动的非基于端口的源（Source） 启动任何准备好的非基于端口的源 如果基于端口的源准备好并处于等待状态，立即启动，处理未处理的事件 通知监听者线程进入休眠 直到以下事件发生，线程将被唤醒某一事件到达基于端口的源定时器启动RunLoop设置的时间已经超时RunLoop被显式唤醒 通知监听者线程将被唤醒 处理未处理事件 通知观察者RunLoop结束 未处理事件定时器启动，处理定时器事件并重启RunLoop输入源启动，传递相应消息被显式唤醒且没有超时，重启RunLoop 应用 NSTimer ImageView显示 performSelector 常驻线程：子线程中开启一个runloop 自动释放池","link":"/2016/09/01/my-ios-day18/"},{"title":"my-ios-day2","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ ##回顾##加法计算器- 控件- 3个UILabel- 2个UITextField- 1个UIButton- 简单逻辑- 取得用户在textField中的输入，判断输入是否满足需求（数字和非空）- 计算结果并显示day 02基本控件 UILabel 显示文本 UIImageView 显示图片 UIButton 按钮 UITextField 文本输入框 UITextView 带滚动条的文本输入框 UIProgressView 进度条 UISlider 滑块 UIActivityIndicator 圈圈 UIAlertView 中间弹框 UIActionSheet 底部弹框 UIScrollView 滚动的view UIPageControl 分页控件 UITableView 表格 UICollectionView 九宫格 UIWebView 显示网页 UISwitch 开关 UISegmentControl 选项卡 UIPickView 选择器 UIDatePicker 日期选择器 UIToolbar 工具条 控件学习UILabel 经常使用的控件，显示文字 常见属性12345678@property(nullable, nonatomic,copy) NSString *text; // 显示的文字@property(null_resettable, nonatomic,strong) UIFont *font; // 字体@property(null_resettable, nonatomic,strong) UIColor *textColor; // 文字的颜色@property(nullable, nonatomic,strong) UIColor *shadowColor; // 文字的阴影颜色@property(nonatomic) CGSize shadowOffset; // 文字的阴影偏移@property(nonatomic) NSTextAlignment textAlignment; // 文字对方式@property(nonatomic) NSLineBreakMode lineBreakMode; // 换行模式@property(nonatomic) NSInteger numberOfLines; // 文字行数，0表示换行 UIColor类 表示颜色 常用方法123456789+ (UIColor *)blackColor; // 0.0 white+ (UIColor *)whiteColor; // 1.0 white+ (UIColor *)grayColor; // 0.5 white+ (UIColor *)redColor; // 1.0, 0.0, 0.0 RGB+ (UIColor *)greenColor; // 0.0, 1.0, 0.0 RGB+ (UIColor *)blueColor; // 0.0, 0.0, 1.0 RGB+ (UIColor *)clearColor; // 0.0 white, 0.0 alpha- (UIColor *)initWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha; // 使用aRGB初始化颜色- (UIColor *)initWithPatternImage:(UIImage*)image; // 图片中获取均色 UIFont类 表示字体 常用方法123+ (UIFont *)systemFontOfSize:(CGFloat)fontSize; // 系统默认字体+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize; // 粗体+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize; // 斜体 shadowOffset 阴影CGSizeMake(x, y); x&gt;0 向右偏 y&gt;0 向下偏 textAlignment123- NSTextAlignmentLeft 左对齐- NSTextAlignmentCenter 居中- NSTextAlignmentRight 右对齐 lineBreakMode12345- NSLineBreakByWordWrapping = 0, 按单词换行，默认的- NSLineBreakByCharWrapping, 按字母换行- NSLineBreakByTruncatingHead, 开始省略&quot;...wxyz&quot;- NSLineBreakByTruncatingTail, 结尾省略 &quot;abcd...&quot;- NSLineBreakByTruncatingMiddle, 中间省略 &quot;ab...yz&quot; UIImageView 常用控件，显示图片，播放帧动画 常见属性1234@property(nonatomic,retain) UIImage *image; // 显示的图片@property(nonatomic,copy) NSArray *animationImages; // 显示的动画图片@property(nonatomic) NSTimeInterval animationDuration; // 动画图片的持续时间@property(nonatomic) NSInteger animationRepeatCount; // 动画的播放次数（默认是0，代表无限播放） 常见方法123- (void)startAnimating; // 开始动画- (void)stopAnimating; // 停止动画- (BOOL)isAnimating; // 是否正在执行动画 UIImage类 常用创建方法12+ (UIImage *)imageNamed:(NSString *)name; // 图片名+ (UIImage *)imageWithContentsOfFile:(NSString *)path; // 图片全路径 图片拉伸代码12- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode UIButton 可以和用户交互，显示图片和文字 状态 normal 普通状态，默认状态Default， UIControlStateNormal highlighted 高亮状态，按钮被按下的状态，手没有抬起， UIControlStateHighlighted disable 失效状态，不能点击的状态， UIControlStateDisabed 设置1234- (void)setTitle:(NSString *)title forState:(UIControlState)state; // 设置按钮的文字- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state; // 设置按钮的文字颜色- (void)setImage:(UIImage *)image forState:(UIControlState)state; // 设置按钮内部的小图片- (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state; // 设置按钮的背景图片 监听事件 拖线 代码12// 按钮点击后就会调用self的btnClick:方法，并将按钮本身作为参数传递过去[button addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside]; 内部子控件 一个UILabel和一个UIImageView 不可以直接改变button内部子控件的位置 自定义的时候，需要重写两个方法12345- (CGRect)titleRectForContentRect:(CGRect)contentRect{}- (CGRect)imageRectForContentRect:(CGRect)contentRect{}- (void)layoutSubviews {[super layoutSubviews];} 内边距属性 contentEdgeInsets 所有内容的内边距 titleEdgeInsets 文字的内边距 imageEdgeInsets 图片的内边距 ##拳皇小例子 帧动画1234self.imageView.animationImages = images; // 动画需要图片数组self.imageView.animationRepeatCount = repeatCount; // 动画播放次数self.imageView.animationDuration = duration; // 每次的播放时间[self.imageView startAnimating]; // 开始动画","link":"/2016/09/01/my-ios-day2/"},{"title":"my-ios-day3","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ ##回顾 UIImageView图片的两种加载方式没有缓存NSString *file = [[NSBundle mainBundle] pathForResource:@”图片名” ofType:@”图片扩展名”];UIImage *image = [UIImage imageWithContentOfFile:file];*只要方法名带有file的，都是传全路径使用场合：图片比较大，使用频率比较低建议：不需要缓存的图片不能放在Assets.xcassets中放到Assets.xcassets中的图片只能通过图片名去加载，苹果会压缩图片，而且默认带有缓存。UIImage *image = [UIImage imageNamed:@”图片名”]; 延迟做一些事情iOS中有很多方式(GCD,dispatch…)[abc performSelector:@selector(stand:) withObject:@”123” afterDelay:10];// 10秒后调用abc的stand：方法，并且传递@“123”参数 简单的音频播放使用AVFoundation框架AVPlayer *player = [[AVPlayer alloc] init];NSURL *url = [[NSBundle mainBundle] URLForResource:@”yinyue.mp3” withExtension:nil];AVPlayerItem *item = [[AVPlayerItem alloc] initWithURL:url];[player replaceCurrentItemWithPlayerItem:item];[player play]; day 03购物车简单实现 九宫格布局 横向，y值：不变，x值：（间距 + 宽度）* （下标 % 总列数） 纵向，x值：不变，y值：（间距 + 高度）* （下标 / 总行数） Plist文件的读取NSBundle *bundle = [NSBundle mainBundle];NSString *path = [bundle pathForResource:@”filename” ofType:@”plist”];_data = [NSArray arrayWithContentsOfFile:path]; // _data保存数据的数组 懒加载 1234567- (NSArray *)data{if(_data == nil) {// 初始化data的代码}return _data;} 面向字典编程 将数据以字典的方式存储，存取数据要使用key，容易敲错 dict[@”name”] = @”Sleen”; 面向模型编程 Model，将数据对象封装成一个继承自NSObject的类，数据对象的属性作为成员变量 存取数据依靠属性，属性名写错就会直接报错，提高编程效率 person.name = @”Sleen”; xib的使用 注册 1234567@interface SLXibView : UIView+ (instancetype)xibView;@end@implementation SLXibView+ (instancetype)xibView {return [[[NSBundle mainBundle] loadNibNamed:@&quot;SLXibView&quot; owner:nil options:nil] lastobject];} 简单注意 控件有两种创建方式 通过代码创建，初始化的时候一定会调用initWithFrame:方法 通过xib/storyboard创建，初始化时不会调用initWithFrame:方法，只会调用initWithCoder:方法，初始化完毕会调用awakerFromNib方法 有时候需要在初始化时做一些事情，如：添加子控件，设置属性 要根据控件的创建方式来选择对应的方法","link":"/2016/09/01/my-ios-day3/"},{"title":"my-ios-day4","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day04##控件学习####UIScrollView 基本使用 移动设备的屏幕大小是及其有限的，需要展示的内容较多，需要用户使用滚动手势查看屏幕以外的内容 将要展示的内容添加到UIScrollView中，设置UIScrollView的contentSize属性 常见属性123456789101112// 表示scrollView的滚动位置，内容左上角与scrollV左上角的间距值@property(nonatomic) CGPoint contentOffSet；// 表示scrollView中内容的位置，滚动范围@property(nonatomic) CGSize contentSize;// 在scrollView的四周添加额外的滚动区域@property(nonatomic) UIEdgeInsets contentInset// 设置scrollView是否需要弹簧效果@property(nonatomic) BOOL bounces;// 是否显示垂直滚动条@property(nonatomic) BOOL alwaysBounceVertical;// 是否显示水平滚动条@property(nonatomic) BOOL alwaysBounceHorizontal; 代理 需要监听UIScrollView的滚动过程，需要使用UIScrollView的代理1@property(nullable, nonatomic, weak) id&lt;UIScrollViewDelegate&gt; delegate; 代理实现缩放1234567// 设置minimumZoomScale(缩放最小比例)和maximumZoomScale(缩放最大比例)// 返回需要缩放的控件- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;// 即将开始缩放的时候调用- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view// 正在缩放的时候调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView; 代理监听滚动12345678// 当scrollView正在滚动的时候就会自动调用这个方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView;// 用户即将开始拖拽scrollView时就会调用这个方法- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;// 用户即将停止拖拽scrollView时就会调用这个方法- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset;// scrollView减速完毕会调用,停止滚动- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView 分页功能 设置UIScrollView的pagingEnabled = YES开启分页功能，以scrollView的尺寸为一页 UIPageControl增强分页效果12345@property(nonatomic) NSInteger numberOfPages; // 一共有多少页@property(nonatomic) NSInteger currentPage; // 当前显示页码@property(nonatomic) BOOL hidesForSinglePage; // 分一页时是否隐藏页码指示器@property(nonatomic, reatain) UIColor *pageIndicatorTintColor; // 其他页码指示器的颜色@property(nonatomic, reatain) UIColor *currentPageIndicatorTintColor; // 当前页码指示器的颜色 NSTimer自动滚动1234// 每隔2秒调用self的next方法NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(next) userInfo:nil repeats:YES];// 解决定时器在主线程不工作的问题[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; KVC 简单赋值12- (void)setValue:(nullable id)value forKey:(NSString *)key;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; forKey和forKeyPath forKeyPath 包含了所有 forKey 的功能 forKeyPath 进行内部的点语法,层层访问内部的属性 注意: key值一定要在属性中找到 修改私有成员变量12SLPerson *person = [[SLperson alloc] init];[person setValue:@&quot;18&quot; forKeyPath:@&quot;_age&quot;]; age 是SLPerson的私有成员，可以通过kvc修改它的值 取值1- (nullable id)valueForKeyPath:(NSString *)keyPath; KVO Key Value Observing (键值监听)，当某个对象的属性值发生改变的时候(用KVO监听) 添加监听1- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 移除监听1- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 监听事件123456789/*** 当监听的属性值发生改变** @param keyPath 要改变的属性* @param object 要改变的属性所属的对象* @param change 改变的内容* @param context 上下文*/- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:(nullable void *)context; 广告轮播器的实现","link":"/2016/09/01/my-ios-day4/"},{"title":"my-ios-day5","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ 回顾 封装广告轮播 day 05自动布局Autoresizing storyboard 代码12345678UIViewAutoresizingFlexibleLeftMargin // 距离父控件的左边是可以伸缩的UIViewAutoresizingFlexibleBottomMargin // 距离父控件的底部是可以伸缩的UIViewAutoresizingFlexibleRightMargin // 距离父控件的右边是可以伸缩的UIViewAutoresizingFlexibleTopMargin // 距离父控件的顶部是可以伸缩的UIViewAutoresizingFlexibleHeight // 高度会跟随父控件的高度进行伸缩UIViewAutoresizingFlexibleWidth // 宽度会跟随父控件的宽度进行伸缩// 设置autoresizingMask属性redView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin; Autoresizing仅能解决父子控件之间的相对关系，比较有局限性 Autolayout 简介 约束：通过给控件添加约束，来决定控件的位置和尺寸 参照：在添加约束的时候需要选择参照物，父控件或兄弟控件 storyboard 代码 使用NSLayoutConstraint类创建具体的约束对象 添加约束到相应的View上12- (void)addConstraint:(NSLayoutConstraint *)constraint; // 添加一个- (void)addConstraints:(NSArray*)constraints; // 添加多个 注意点 需要先禁止autoresizing功能，view.translatesAutoresizingMaskIntoConstraint = NO; 添加约束的时候一定要确定控件已经添加到了父控件上 不需要再设置frame值 核心计算公式 obj1.property1 = (obj2.proterty2 * multiplier) + constant value 添加约束规则 两个同层view(亲兄弟型)之间的约束关系，添加到他们的父view上 对于两个不同层view(堂兄弟型)之间的约束关系，添加到他们最近的共同父view上 对于有层次关系的view(父子型)之间的约束关系，添加到层次较高的view上 VFL语言 Visual Format Language，可视化格式语言，苹果味监护Autolayout代码而推出的抽象语言 简单示例12H:[cancelBtn(70)-12-[acceptBtn(50)]] cancelBtn宽70，acceptBtn宽50，之间间距12V:[redView][yellowView(==redView)] 竖直方向上，先有一个redView，下面有一个和redView等高的yellowView 使用VFL创建约束数组 (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;format：VFL语句，opts：约束类型，metrics：VFL语句中用到的具体数值，views：VFL语句中用到的控件 小示例123NSString *vvfl = @&quot;V:[blueView(50)]-space-|&quot;;NSArray *vlcs = [NSLayoutConstraint constraintsWithVisualFormat:vvfl options:kNilOptions metrics:metrics views:views];[self.view addConstraints:vlcs]; Masonry框架 自动布局小例子","link":"/2016/09/01/my-ios-day5/"},{"title":"my-ios-day6","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 06UITableView数据源 数据源简介 tableView需要一个数据源来显示数据 tableView会向数据源查询有多少行数据，每行数据是什么 凡是遵守UITableViewDataSource协议的OC对象，都可以成为数据源 数据源协议123456// 一共有多少组数据- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;// 每一组有多少行数据- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;// 每一行显示什么内容- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; ####常见设置12345678910111213141516171819// 设置tableView每一行cell的高度，默认是44self.tableView.rowHeight = 80;// 设置tableView每⼀一组头部的⾼高度￼self.tableView.sectionHeaderHeight = 50;￼// 设置tableView每⼀一组尾部的⾼高度￼self.tableView.sectionFooterHeight = 50;￼// 设置分割线的颜色，如果设置[UIColor clearColor]隐藏分割线￼self.tableView.separatorColor = [UIColor redColor];￼// 设置分割线的样式￼self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;￼// 设置表头￼self.tableView.tableHeaderView = [[UISwitch alloc] init] ;￼// 设置表尾￼self.tableView.tableFooterView = [UIButton￼buttonWithType:UIButtonTypeContactAdd];￼// 设置索引条上⽂文字颜⾊色￼self.tableView.sectionIndexColor = [UIColor redColor];￼// 设置索引条的背景颜⾊色￼self.tableView.sectionIndexBackgroundColor = [UIColor blackColor];####代理12345678910111213141516171819202122232425262728/*** 当选中某一行cell就会调用*/￼- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:￼(NSIndexPath *)indexPath{}￼/**￼* 当取消选中某⼀一⾏行cell就会调⽤用￼*/￼- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:￼(NSIndexPath *)indexPath{}/*** 返回每一组显示的头部控件*/- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{}/*** 返回每一组显示的尾部控件*/- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section{}/*** 返回每一组头部的高度*/￼- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{}/*** 返回每一组尾部的高度*/￼- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section{}/*** 返回tableView的每一行高度*/￼- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:￼(NSIndexPath *)indexPathUITableViewCell 简介 tableView的每一行都是一个UITableViewCell，通过dataSource的tableView: cellForRowAtIndexPath:方法初始化每一行 UITableViewCell内部有一个默认的子视图contentView，contentView是cell内部所有控件的父控件 常见设置1234567891011121314151617// 设置cell右边的指⽰示控件￼cell.accessoryView = [[UISwitch alloc] init];￼// 设置cell右边的指⽰示样式(accessoryView优先级 &gt; accessoryType)￼cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;￼// 设置cell的背景view￼// backgroundView优先级 &gt; backgroundColor￼UIView *bg = [[UIView alloc] init];￼bg.backgroundColor = [UIColor blueColor];￼cell.backgroundView = bg;￼// 设置cell的背景颜⾊色￼cell.backgroundColor = [UIColor redColor];￼// 设置cell选中的背景view￼UIView *selectbg = [[UIView alloc] init];￼selectbg.backgroundColor = [UIColor purpleColor];￼cell.selectedBackgroundView = selectbg;￼// 设置cell选中的样式cell.selectionStyle = UITableViewCellSelectionStyleNone; cell重用 第一种123456789101112- (void)viewDidLoad {[super viewDidLoad];￼// 根据ID 这个标识 注册对应的 cell类型￼[self.tableView registerClass:[UITableViewCell class] ￼forCellReuseIdentifier:ID];}- (UITableViewCell *)tableViewew:(UITableView *)tableView￼cellForRowAtIndexPath:(NSIndexPath *)indexPath {// 1.首先去缓存池中查找可循环利用的cellUITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:ID];// 2.设置数据cell.textLabel.text = [NSString stringWithFormat:@&quot;第%ld行数据&quot;, indexPath.row];return cell;} 第二种1234567891011- (UITableViewCell *)tableViewew:(UITableView *)tableView￼cellForRowAtIndexPath:(NSIndexPath *)indexPath {// 1.首先去缓存池中找可以循环利用的cellUITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:ID];// 2.如果缓存池中的cell为空，就创建一个cellif (cell == nil) {cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];}// 3.设置数据cell.textLabel.text = [NSString stringWithFormat:@&quot;第%ld行数据&quot;, indexPath.row];return cell;} 自定义cell 自定义等高cell 代码方式 新建一个继承自UITableViewCell的子类，如SLOwnCell12@interface SLOwnCell : UITableViewCell@end 在SLOwnCell.m文件中重写-initWithStyle:reuseIdentifier:方法，添加子控件，给控件做一些一次性的初始化（如使用自动布局可在此方法中为控件添加完整约束）12345678// 添加所有子控件- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {// code...}return self;} 重写-layoutSubviews方法，一定要调用[super layoutSubviews]，在这个方法中计算和设置所有子控件的frame123456// 布局内部子控件- (void)layoutSubviews{[super layoutSubviews];// code...} 在SLOwnCell.h中提供一个模型属性，如SLOwn模型1234@class SLOwn;@interface SLOwnCell : UITableViewCell@property (nonatomic, strong) SLOwn *own;@end 在SLOwnCell.m中重写模型属性的set方法，同时为cell中的子控件添加数据12345- (void)setOwn:(SLOwn *)own{_own = own; // 先要进行set方法的赋值// 为子控件添加数据...} 在viewController中注册cell，并给cell传递模型123456789// 注册cell[self.tableView registerClass:[SLOwnCell class] forCellReuseIdentifier:ID];// 传递模型- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{SLOwnCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];cell.own = self.owns[indexPath.row];return cell;} xib方式 新建一个继承自UITableViewCell的子类，如SLOwnCell12@interface SLOwnCell : UITableViewCell@end 新建一个xib文件，文件名最好和类名相同，如SLOwnCell.xib 修改cell的class为SLOwnCell 为cell绑定循环利用标识 添加子控件，设置完整约束 将子控件拖线到类扩展中12345@interface SLOwnCell ()@property (weak, nonatomic) IBOutlet UIImageView *iconView;@property (weak, nonatomic) IBOutlet UILabel *titleLabel;@property (weak, nonatomic) IBOutlet UILabel *priceLabel;@end 添加模型和重写set方法（与代码方式相同） 在viewController中，需要注册xib文件12// 注册xib文件[self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([XMGTgCell class]) bundle:nil] forCellReuseIdentifier:ID]; storyboard方式 基本方法与xib相同，只是不需要注册 在添加控件的时候，要加入到cell的contentView中 自定义不等高cell 主要通过代码的方式实现 基本思路等高cell相同，主要介绍一些区别支出 需要添加一个frame模型，如SLOwnFrame，12345678910111213@class SLOwn;@interface SLOwnFrame : NSObject// 头像的frame@property (nonatomic, assign, readonly) CGRect iconFrame;// 标题的frame@property (nonatomic, assign, readonly) CGRect titleFrame;// 价格的frame@property (nonatomic, assign, readonly) CGRect priceFrame;// cell的高度@property (nonatomic, assign, readonly) CGFloat cellHeight;// 数据模型@property (nonatomic, strong) SLOwn *own;@end 在frame模型的setOwn:方法中，根据own模型中的数据计算各个控件的frame 在自定义的SLOwnCell文件中包含SLOwnFrame模型1234@class SLOwnFrame;@interface SLOwnCell : UITableViewCell@property (nonatomic, strong) SLOwnFrame *ownFrame;@end 在重写setOwnFrame:方法的时候需要进行数据和frame的设置12345678910111213- (void)setOwnFrame:(SLOwnFrame *)ownFrame{_ownFrame = ownFrame;[self setData];[self setFrame];}- (void)setData{// 设置子控件的数据}- (void)setFrame {// 设置子控件的frame} 在viewController中字典转模型后，将own赋值给ownFrame，数组中存储的是SLOwnFrame模型 通过数据源的tableView: heightForRowAtIndexPath:方法得到每一行cell的高度12345- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{SLOwnFrame *oframe = self.ownFrames[indexPath.row];return oframe.cellHeight;}","link":"/2016/09/01/my-ios-day6/"},{"title":"my-ios-day7","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ day 07UITableView简单的MVC MVC是一种程序设计思想，在iOS开发中十分重要 MVC中的三个角色 M：Model，模型 V：View，视图 C：Control，控制中心 MVC的特征和体现 View上面显示的什么，取决于Model 只要Model中的数据修改，View的显示状态会跟着改变 Control负责初始化Model，并将Model传递给View去解析展示 数据刷新 全局刷新12// 所有屏幕上的cell都会刷新[self.tableView reloadData]; 局部刷新123456// 插入，- (void)insertRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;// 删除- (void)deleteRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;// 刷新部分cell- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths 左滑删除123456789101112/*** 只要实现这个方法，就拥有左滑删除的功能* 点击左滑出现的Delete，就会调用这个方法*/- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;/*** 修改默认Delete按钮的文字*/- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{return @&quot;删除&quot;;} 左滑出现多个按钮实现tableView的代理方法12345678910111213141516171819202122232425/*** 只要实现了这个方法，左滑出现按钮的功能就有了* 出现按钮后，tableView就会进入编辑模式*/- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath{}/*** 左滑出现什么按钮*/- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath{UITableViewRowAction *action0 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;置顶&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) {NSLog(@&quot;点击了置顶&quot;);// 置顶代码...// 收回左滑出现的按钮(退出编辑模式)tableView.editing = NO;}];UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;删除&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) {[self.wineArray removeObjectAtIndex:indexPath.row];[tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];}];return @[action1, action0];} 编辑模式 进入编辑模式1[self.tableView setEditing:YES animated:YES]; 编辑模式多选123456// 允许多选self.tableVew.allowMultipleSelectDuringEditing = YES;// 进入编辑模式[self.tableView setEditing:YES animated:YES];// 获得选中的所有行self.tableView.indexPathsForSelectedRows;","link":"/2016/09/01/my-ios-day7/"},{"title":"my-ios-day8","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ #day 08 简单购物车 关注点 storyboard自定义等高cell 简单MVC 代理设计模式 圆角按钮 基本步骤 storyboard界面 添加数据源12345678910111213141516171819202122#pragma mark - 懒加载，模型解析- (NSArray *)wines {if (_wines == nil) {_wines = [SLWine mj_objectArrayWithFilename:@&quot;wine.plist&quot;];}return _wines;}#pragma mark - UITableView数据源方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{return self.wines.count;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{SLWineTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;wine&quot;];if (!cell) {cell = [[SLWineTableViewCell alloc] init];}cell.wine = self.wines[indexPath.row];cell.delegate = self;return cell;} 自定义cell 新建SLWineTableViewCell类，设置storyboard的cell为但钱类，拖线拿到相应控件属性和事件1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface SLWineTableViewCell ()/** 图片标签 */@property (nonatomic, weak) IBOutlet UIImageView *iconView;/** 名字标签 */@property (nonatomic, weak) IBOutlet UILabel *nameLabel;/** 价钱标签 */@property (nonatomic, weak) IBOutlet UILabel *priceLabel;/** 加一个按钮 */@property (nonatomic, weak) IBOutlet SLCircleButton *ad dButton;/** 减一个按钮 */@property (nonatomic, weak) IBOutlet SLCircleButton *removeButton;/** 数量标签 */@property (nonatomic, weak) IBOutlet UILabel *numLabel;@end@implementation SLWineTableViewCell- (IBAction)addButton:(UIButton *)button {self.wine.count += 1;self.removeButton.enabled = YES;self.numLabel.text = [NSString stringWithFormat:@&quot;%d&quot;, self.wine.count];if ([self.delegate respondsToSelector:@selector(wineTableViewCell: addbuttonClick:)]) {[self.delegate wineTableViewCell:self addbuttonClick:button];}}- (IBAction)removeButton:(UIButton *)button {self.wine.count -= 1;self.numLabel.text = [NSString stringWithFormat:@&quot;%d&quot;, self.wine.count];if (self.wine.count == 0) {button.enabled = NO;}if ([self.delegate respondsToSelector:@selector(wineTableViewCell: removebuttonClick:)]) {[self.delegate wineTableViewCell:self removebuttonClick:button];}}- (void)setWine:(SLWine *)wine {_wine = wine;self.iconView.image = [UIImage imageNamed:wine.image];self.nameLabel.text = wine.name;self.priceLabel.text = [NSString stringWithFormat:@&quot;¥%@&quot;, wine.money];self.numLabel.text = [NSString stringWithFormat:@&quot;%d&quot;, self.wine.count];if (self.wine.count == 0) {self.removeButton.enabled = NO;}}@end cell的代理 12345678910111213#import &lt;UIKit/UIKit.h&gt;@class SLWine, SLWineTableViewCell;@protocol SLWineTableViewCelldelegate &lt;NSObject&gt;@optional- (void)wineTableViewCell:(SLWineTableViewCell *)cell addbuttonClick:(UIButton *)button;- (void)wineTableViewCell:(SLWineTableViewCell *)cell removebuttonClick:(UIButton *)button;@end@interface SLWineTableViewCell : UITableViewCell/** 酒模型 */@property (nonatomic, strong) SLWine *wine;/** Cell的代理 */@property (nonatomic, weak) id&lt;SLWineTableViewCelldelegate&gt; delegate;@end 圆角按钮 自定义按钮SLCircleButton 头文件SLCircleButton.h123#import &lt;UIKit/UIKit.h&gt;@interface SLCircleButton : UIButton@end 实现SLCircleButton.m123456789101112#import &quot;SLCircleButton.h&quot;@implementation SLCircleButton- (void)awakeFromNib{// 设置边框宽度self.layer.borderWidth = 1.0;// 设置边框颜色self.layer.borderColor = [UIColor redColor].CGColor;// 设置圆角半径self.layer.cornerRadius = self.frame.size.width * 0.5;}@end iOS通知机制 要点 通知的发布 通知的监听 通知的移除 通知中心 每一个应用程序都有一个通知中心NSNotificationCenter实例，专门负责协助不同对象之间的消息通信 任何一个对象都可以向通知中心发布通知NSNotification，描述自己在做什么 其他感兴趣的对象Observer可以申请在某个特定通知发布时(或在某个特定的对象发布通知时)收到这个通知 通知简介 三个属性123- (NSString *)name; // 通知的名称- (id)object; // 通知发布者(是谁要发布通知)- (NSDictionary *)userInfo; // 一些额外的信息(通知发布者传递给通知接收者的信息内容) 初始化123+ (instancetype)notificationWithName:(NSString *)aName object:(id)anObject;+ (instancetype)notificationWithName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;- (instancetype)initWithName:(NSString *)name object:(id)object userInfo:(NSDictionary *)userInfo; 通知发布 通知中心NSNotificationCenter提供了相应的方法来帮助发布通知123456// 发布一个notification通知，可在notification对象中设置通知的名称、通知发布者、额外信息等- (void)postNotification:(NSNotification *)notification;// 发布一个名称为aName的通知，anObject为这个通知的发布者- (void)postNotificationName:(NSString *)aName object:(id)anObject;// 发布一个名称为aName的通知，anObject为这个通知的发布者，aUserInfo为额外信息- (void)postNotificationName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo; 通知监听 注册监听器，通知中心NSNotificationCenter提供了方法来注册一个监听通知的监听器Observer1234567891011121314/*** observer：监听器，即谁要接收这个通知* aSelector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入* aName：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知* anObject：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知*/- (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject;/*** name：通知的名称* obj：通知发布者* block：收到对应的通知时，会回调这个block* queue：决定了block在哪个操作队列中执行，如果传nil，默认在当前操作队列中同步执行*/- (id)addObserverForName:(NSString *)name object:(id)obj queue:(NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block; 移除监听12- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject; UIDecive的通知 UIDevice类提供了一个单粒对象，它代表着设备，通过它可以获得一些设备相关的信息 电池电量值(batteryLevel) 电池状态(batteryState) 设备的类型(model，比如iPod、iPhone等) 设备的系统(systemVersion) 通过[UIDevice currentDevice]可以获取这个单粒对象 UIDevice对象会不间断地发布一些通知UIDeviceOrientationDidChangeNotification // 设备旋转UIDeviceBatteryStateDidChangeNotification // 电池状态改变UIDeviceBatteryLevelDidChangeNotification // 电池电量改变UIDeviceProximityStateDidChangeNotification // 近距离传感器(比如设备贴近了使用者的脸部) 键盘的通知 我们经常需要在键盘弹出或者隐藏的时候做一些特定的操作,因此需要监听键盘的状态 键盘状态改变的时候,系统会发出一些特定的通知UIKeyboardWillShowNotification // 键盘即将显示UIKeyboardDidShowNotification // 键盘显示完毕UIKeyboardWillHideNotification // 键盘即将隐藏UIKeyboardDidHideNotification // 键盘隐藏完毕UIKeyboardWillChangeFrameNotification // 键盘的位置尺寸即将发生改变UIKeyboardDidChangeFrameNotification // 键盘的位置尺寸改变完毕 系统发出键盘通知时,会附带一下跟键盘有关的额外信息(字典),字典常见的key如下:UIKeyboardFrameBeginUserInfoKey // 键盘刚开始的frameUIKeyboardFrameEndUserInfoKey // 键盘最终的frame(动画执行完毕后)UIKeyboardAnimationDurationUserInfoKey // 键盘动画的时间UIKeyboardAnimationCurveUserInfoKey // 键盘动画的执行节奏(快慢) 通知和代理 共同点利用通知和代理都能完成对象之间的通信(比如A对象告诉D对象发生了什么事情, A对象传递数据给D对象) 区别 代理 : 1个对象只能告诉另1个对象发生了什么事情 通知 : 1个对象能告诉N个对象发生了什么事情, 1个对象能得知N个对象发生了什么事情","link":"/2016/09/01/my-ios-day8/"},{"title":"my-ios-day9","text":"这个是16年重新复习的iOS笔记，当时是放在了gitbook，现在转移过来！ #day 09 UIPickerView简介 使用 通常应用在注册模块，当需要选择一些固定的选项时使用 老虎机效果 常见用法 单一列，菜单系统 关联的，省市选择 带图片的，国旗选择 UIDatePicker 系统自带的日期选择 基本使用 显示数据 与tableView一样，显示数据需要设置数据源和代理12self.pickerView.dataSource = self;self.pickerView.delegate = self; 遵守相应协议123@interface ViewController () &lt;UIPickerViewDataSource, UIPickerViewDelegate&gt;@property (weak, nonatomic) IBOutlet UIPickerView *pickerView;@end 实现相应方法123456789101112// 总过有多少列- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView{}// 第component有多少行- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component{}// 返回每一列的宽度- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent: (NSInteger)component{}// 返回第一列的高度- (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component{}// 返回每⼀⾏的标题- (nullable NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component{}// 返回每⼀一⾏行的视图UIView- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow: (NSInteger)row forComponent:(NSInteger)component reusingView: (nullable UIView *)view{} 简单Demo 拦截用户输入—— UITextField的代理 控制器成为textField的代理，监听文本框的改变 实现代理方法1234567891011121314151617181920// 是否允许开始编辑- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField {return YES;}// 开始编辑时调⽤用，(弹出键盘)第一响应者- (void)textFieldDidBeginEditing:(UITextField *)textField {NSLog(@&quot;弹出键盘&quot;);}// 是否允许结束编辑- (BOOL)textFieldShouldEndEditing:(UITextField *)textField {return YES;}// 结束编辑时调⽤用- (void)textFieldDidEndEditing:(UITextField *)textField {NSLog(@&quot;结束编辑时调⽤用.&quot;);}// 是否允许⽂文字改变，拦截⽤用户输⼊入- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {return NO;} 自定义国旗选择 自定义省市选择","link":"/2016/09/01/my-ios-day9/"},{"title":"nginx 配置 gzip","text":"nginx 配置开启 gzip 压缩 123456gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_comp_level 2;gzip_types text/plain application/json application/javascript application/x-javascript text/css application/xml text/javascript image/jpeg image/gif image/png;gzip_vary off;","link":"/2019/09/26/nginx-gzip-md/"},{"title":"openshift-deploy-flask","text":"新版 Openshift 部署 Flask+mongodb 应用 Openshift Openshift 是红帽的云开发平台即服务 (Pass)。之前的旧版本已经停止使用，新的 Openshift V3 已经全面的开放使用。 新版本的免费空间提供 1 Project (1G Memory, 1G Storage)，对于我们部署一个简单的应用足够了。 想要开始需要先注册 Openshift 的账号，具体注册流程不做介绍，可以参考免费资源部落的第一步。 Project 登录账号后就就可以创建 Project 点击 Create 后，会要求我们选择想要语言、技术等，因为要使用 MongoDB，所有先选择 Data Stores MongoDB 接下来在选择 MongoDB(Persisent) 之后的页面需要我们对 MongoDB 设置一些参数 等待一段时间就会创建成功，创建成功后我们可以通过 面板的 Applications-Service 来查看 MongoDB 的主机地址 Flask 接下来添加 Flask 应用，点击顶部的 Add to Project - Browse Catalog，接下来的页面选择 Python，还需要选择 Python 版本 (我选择的是 2.7)。 设置 Flask 应用的一些信息，设置 git 仓库 (可以参考我的代码https://github.com/SleenXiu/openshift-flask.git) 点击 advanced options 填写一些额外的配置 设置内存限制 设置git push 自动部署 数据库配置 1234567// 填写上面 MongoDB 中填写的信息MONGODB_SETTINGS = { 'db': 'xiudb', 'host': '172.30.224.230:27017', 'username': 'xiu', 'password': 'xiu'} 最后 利用业余时间研究了很久，终于完成了新版 Openshift 的部署，小站，算是跑通了流程吧，有时间再去深入研究下 Docker 第一次使用 Docker，还有很多不了解的地方 前期也就先这样吧，特别感谢RedHat，一直是使用它的免费云平台来学习。","link":"/2017/09/10/openshift-deploy-flask/"},{"title":"由“俩数之和问题”所想","text":"leetcode 第一个问题的一些反思 问题 Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 对于基本知识的理解，Hash Table 的使用不够灵活 对于问题的思考方式，需要把问题简单化，但也不能因为简单而把代码搞复杂 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def twoSum1(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; for i in range(len(nums)): for j in range(i+1, len(nums)): if (nums[i] + nums[j]) == target: return [i, j] def twoSum2(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; d = dict() for i in range(len(nums)): d[nums[i]] = i for i in range(len(nums)): a = target - nums[i] if a in d.keys() and d[a] != i: return [i, d[a]] def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; d = dict() for i in range(len(nums)): a = target - nums[i] if a in d.keys(): return [d[a], i] d[nums[i]] = i","link":"/2019/01/16/think-of-two-sum/"},{"title":"“最长子序列问题” 思考","text":"Longest Word in Dictionary through Deleting “最长子序列问题” 思考 12345678910111213141516171819202122232425&gt; Longest Word in Dictionary through Deleting&gt; Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.Example 1:Input:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output:&quot;apple&quot;Example 2:Input:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Output:&quot;a&quot;&gt; Note:&gt; All the strings in the input will only contain lower-case letters.&gt; The size of the dictionary won't exceed 1,000.&gt; The length of all the strings in the input won't exceed 1,000. 双指针的方式解决 123456789101112131415161718192021222324class Solution: def findLongestWord(self, s, d): &quot;&quot;&quot; :type s: str :type d: List[str] :rtype: str &quot;&quot;&quot; def is_valid(s, word): i, j = 0, 0 while i &lt; len(s) and j &lt; len(word): if s[i] == word[j]: j += 1 i += 1 return j == len(word) longest = '' for word in d: l1, l2 = len(longest), len(word) if l1 &gt; l2 or (l1 == l2 and longest &lt; word): continue if is_valid(s, word): longest = word return longest 问题描述里有很多 python 的高级写法 LINK 12345def findLongestWord(self, s, d): def isSubsequence(x): it = iter(s) return all(c in it for c in x) return max(sorted(filter(isSubsequence, d)) + [''], key=len) fliter 函数 过滤序列，过滤掉不符合条件的元素，返回符合条件的元素组成的新序列，新序列是一个迭代器 接受两个参数，第一个是过滤函数，第二的是可迭代对象 语法 filter(function, iterable) 例子1234def is_odd(x): return x%2 == 1list2 = filter(is_odd, [1, 3, 5, 6, 7, 8])print(list(list2)) # out [1, 3, 5, 7] 过滤函数对每个元素进行条件判断，返回 bool 值， 换一种写法123456list1 = [1, 3, 5, 6, 7, 8]list2 = []for x in list1: if x%2 == 1: list2.append(x)print(list2) # out [1, 3, 5, 7] all 函数 判断可迭代对象中所有元素是否为 TRUE，如果是放回 True，不是返回 False 这里 TRUE 的定义是除 0、空（None）、False、’’ 都算 TRUE 元素为 0 个的可迭代对象返回 True 语法 all(iterable) 使用12all([1, 2, 3]) # Trueall([1, 2, 0]) # False 等同于12345def all(iterable): for element in iterable: if not element: return False return True 类似的 any 函数，任意元素为 TRUE 就返回 True sorted 函数 对可迭代序列排序生成新序列 max 函数 取出序列中最大的元素 流程分析12345678910it = iter(s) # 将字符串转换为可迭代序列 it = ('a','b','p','c','p','l','e','a')# x = 'ale'(c in it for c in x) # c 元素同时按在 x 中的顺序同时出现在 it 和 x 中，('a', 'l', 'e')all(('a', 'l', 'e')) # 上一步每个元素都不为空时返回 Trued = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]filter(isSubsequence, d) # 对 d 进行过滤，('ale', 'apple', 'plea')sorted(('ale', 'apple', 'plea')) # 上一步的结果进行排序，字典顺序# + [''] 处理为找的情况max(('ale', 'apple', 'plea', ''), key=len) # 根据元素长度取出最长的元素# 'apple' 不使用 sorted123456789def findLongestWord(self, s, d): def isSubsequence(x): it = iter(s) return all(c in it for c in x) return min(filter(isSubsequence, d) + [''], key=lambda x: (-len(x), x))# min(((-3, 'ale'), (-5, 'apple'),(-4, 'plea')))# 'apple'# 巧妙地运用 min 函数对元组的效果 循环替代 filter max12345678def findLongestWord(self, s, d): best = '' for x in d: if (-len(x), x) &lt; (-len(best), best): it = iter(s) if all(c in it for c in x): best = x return best 先进行排序123456def findLongestWord(self, s, d): def isSubsequence(x): it = iter(s) return all(c in it for c in x) d.sort(key=lambda x: (-len(x), x)) return next(itertools.ifilter(isSubsequence, d), '') 先排序，在循环123456def findLongestWord(self, s, d): for x in sorted(d, key=lambda x: (-len(x), x)): it = iter(s) if all(c in it for c in x): return x return '' heapq.heapify 替换 sorted123456789def findLongestWord(self, s, d): heap = [(-len(word), word) for word in d] heapq.heapify(heap) while heap: word = heapq.heappop(heap)[1] it = iter(s) if all(c in it for c in word): return word return ''","link":"/2019/01/19/think-of-longest-word/"},{"title":"图片上传的问题","text":"项目中上传图片的一个特例 后台要求的一个格式 12idcards[0].image // 图片文件idcards[0].side // 图片参数 开始理解是，数组里的两个字典，但这种无法转换为 data 设置给 http.body 12345678910idcards : [ { image: data, side: front }, { image: data, side: back }] 通过postman 来测试接口，发现传的数据原来是这样，瞬间明白 最终构造的请求长这样，应该就是把图片放在字典里上传(╰_╯) 12345678910111213[manager POST:url parameters:@{@&quot;idCards[0].side&quot;:@&quot;front&quot;,@&quot;idCards[1].side&quot;:@&quot;back&quot;} constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { [formData appendPartWithFileData:UIImagePNGRepresentation(images[0]) name:@&quot;idCards[0].image&quot; fileName:@&quot;front.png&quot; mimeType:@&quot;image/png&quot;]; [formData appendPartWithFileData:UIImagePNGRepresentation(images[1]) name:@&quot;idCards[1].image&quot; fileName:@&quot;back.png&quot; mimeType:@&quot;image/png&quot;];} progress:^(NSProgress * _Nonnull uploadProgress) {} success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { !success ? : success(responseObject); [self ic_apiLogWithUrl:url params:params error:nil];} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { !failure ? : failure([self myErrorWithNSError:error]); [self ic_apiLogWithUrl:url params:params error:error];}]; 后台是用 java 写的，具体怎么解析还有待研究","link":"/2019/05/15/upload-file-soso/"},{"title":"曾经的ios01","text":"Objective-C面向对象 类 成员变量尽量不要使用@public，变量的命名以 _ 开头 只读的：只需要提供get方法 set方法：方法名以set开头，后面跟上成员变量的名称，成员变量的首字母大写，返回值是void，接受一个参数（类型与成员变量的类型一致） get方法：返回内部成员变量，一定又返回值（类型与成员变量一致），方法名与成员变量一致（去掉下划线） OC是一种弱语法，会在运行时才检测对象有没有实现相应的方法 对象方法：以减号 － 开头，只能通过对象来调用，对象方法中可以访问当前对象的成员变量 类方法：以加号 ＋ 开头，只能用类来调用，类方法中不能访问成员变量；不依赖对象，执行效率高，当方法内不需要使用成员变量时，可以改用类方法（可允许类方法与对象方法同名） self：指向了方法的调用者，代表着当前对象；谁调用了当前方法，self就代表谁；在对象方法中使用‘self-&gt;成员变量名’访问当前对象内部的成员变量（就像c+中的this），注意在对象方法中使用self调用方法时，不要引发死循环 继承： 为什么使用继承：减少代码重复、建立类之间的关系、子类可以拥有父类的所有成员的方法（所有类都继承与NSObject） 方法的重写：子类重新实现父类中的某个方法，覆盖掉父类以前的做法；父类必须声明在子类的前面、子类不能再次声明父类拥有的成员变量、调用方法时，优先在子类中寻找，如果找不到，在父类中找 什么时候使用继承：当两个类拥有相同的属性和方法时，可以将相同的东西抽取到一个父类中；当A类完全拥有B类的部分属性和方法时，可以考虑让B类继承A类（考虑实际情况）；继承是 is-a的关系 区分组合：组合是has-a的关系 super：直接调用父类中的某个方法；super处在对象方法中，那么就会调用父类的对象方法；super处在类方法中，就会调用父类的类方法。当子类重写父类的方法时想保留父类的一些行为 多态：没有继承就没有多；父类类型的指针指向子类对象；当函数形参为父类类型，那么既可以传入父类对象，也可以传入子类对象；父类对象不能直接调用子类的特有方法，必须进行强制类型转换","link":"/2015/10/01/%E6%9B%BE%E7%BB%8F%E7%9A%84ios01/"},{"title":"曾经的ios02","text":"使用注释 // 要空一格在写 要有一定的编程思想，在对象方法和类方法都计算两点距离时，可以在对象方法（类方法）中调用类方法（对象方法） 返回值时BOOL类型时，方法或函数用is开头 ＃pragm mark – 一段注释 ＃pragm mark 一段注释，可以在快速查看方法的地方看到注释 点语法：是指实质就是方法的调用，要注意在类中使用点语法不要引发死循环 成员变量作用域：@public在任何地方都能直接访问对象的成员变量；@private 只能在当前类中直接访问（@implementation中如果声明比变量，默认就是@private）；@protected 在当前类和子类中可以直接访问（@interface 中就是默认的@protected） @property 可以自动生成某个成员变量的setter和getter方法的声明 @synthesize 可以自动生成某个成员变量setter和getter方法的实现@synthesize age = _age;会访问_age变量，如果不写=_age就会访问age变量；如果类中没有当前要访问的变量，就会自动生成一个（类型为 @private） 在新的版本中，@property的功能更强大：在@interface中直接写 “@property int age；”就会自动有一个­­_age的成员变量，并且生成他的setter和getter方法的声明和实现 id万能指针，能指向、操作任何OC对象 构造方法：用来初始化对象的方法，是一个对象方法，-开头，可以在对象初始的时候成员变量就有一定的值；重写的时候要调用父类的构造方法，在进行子类对象的初始化 自定义构造方法：对象方法，以 – 开头，返回值一般为 id 类型，方法名以 initWith开头 分类：在不改变原来类内容的基础上，为类增加一些新的方法；分类只能增加方法，不能增加成员变量／分类的实现可以访问类中声明的成员变量／分类可以重新实现原类的方法，但会覆盖掉原类的方法／方法的调用顺序：分类，原类，父类 分类：可以为系统的类添加分类。网上有很多写好的分类，拓展了系统类的功能。 类的本质：类也是一个对象，是class类型的对象——类­­­­对象，类＝＝类对象，每个类只有一个类对象；获取内存中的类对象：Class c = [Person class]; ＋load方法：在程序启动时，就会加载项目中所有的类和分类，而加载后就会调用＋load方法，只调用一次 ＋initialize方法：在第一次使用某个类时，就会调用当前类的＋initialize方法 注意：先加载父类，后加载子类－－先调用父类的＋load方法，在调用子类的＋load方法；先初始化父类，后初始化子类——先调用父类的＋initialize方法，在调用子类的＋initialize方法 －description方法：NSLog(@”%d”,p); 就会调用该方法；默认情况下，利用NSLog 和 ％@输出对象时，结果显示&lt;类名:内存地址&gt;；在类中对－description进行重写，让其返回类的所有属性值， ＋description方法：Class c = [Person class]; NSLog(@”%d”,c); 就会调用该方法， SEL 类型：每个类方法列表都存储在类对象中，每个方法都有一个与之对应的SEL类型的对象，根据SEL对象就可以找到方法的地址从而调用方法； _cmd ：代表当前方法 昨天太晚了，宿舍没网就没能贴上今天补上 OC内存管理 每一个Oc对象都有一个引用计数器（占4 个字节），用来保存有多少人在使用该对象，当使用alloc、new、copy创建一个新对象时，对象的引用计数器默认为1，当计数器的值＝0时，对象就会被回收 操作计数器的一些对象方法： retain方法： 计数器加1，会返回对象本身； release方法： 计数器减1，没有返回值； dealloc方法： 返回当前计数器值（ld类型） dealloe方法：当一个对象被回收的时候就会调用，一定要调用会父类的dealloc（[super dealloc];）放在最后面 几个概念： 僵尸对象：所占用的内存已经被回收的对象，不能在进行使用， 野指针：指向僵尸对象（不可用内存）的指针，给野指针发送消息（调用方法）就会报错（EXC_BAD_ACCESS） 空指针：没有指向任何东西的指针（nil、NULL、0），空指针调用方法不会报错 多对象的内存管理 要使用某个对象的时候，就要让对象的计数器加1（让对象做一次retain操做）；不想在使用莫个对象时，就要让对象的计数器减1（让对象做一次release操作） 谁retain 谁release；谁alloc 谁release 类的set方法和dealloc方法 基本数据类型：直接赋值 Oc对象类型：先判断是不是新对象，如果是，对旧对象做一次release，在对新对象做一次retain并赋值 dealloc方法：要先对当前对象拥有的所有Oc对象进行一次release操作，最后调用[super dealloc]; @property的参数 retain：生成的set方法里面，release旧值，retain新值（用于Oc对象） assign：生成的set方法里面，直接赋值（用于非Oc对象，默认的） copy：release旧值，copy新值 readonly：只生成get方法（只读） readwrite：同时生成set和get方法（默认的） 多线程管理 nonatomic：性能高（一定要写这个） atomic：性能低（默认的） set和get方法名 setter重新定义set的方法名；getter重新定义get的方法名；（一般set不会改，当get方法返回BOOL时会改为is开头） 循环引用（你中有我，我中有你） @class xxx：告诉编译器xxx这是一个类，不会包含xxx类的任何内容 开发中：在 .h 文件中使用@class来声明类，在 .m 文件中使用#import来包含类的所有东西 两端循环的解决办法：在@property中，一端用retain，一端用assign autorelease方法 将对象放到一个自动释放池中，当自动释放池被销毁时，会对池子中的所有对象进行一次release操作 会返回对象本身，调用后，对象的计数器数并不变 开发中，经常会将 1[[[Car alloc] init] autorelease]封装到一个类方法（car）中；要是想要带初始值的（carWithSpeed：//方法中创建对象使用self）","link":"/2015/10/02/%E6%9B%BE%E7%BB%8F%E7%9A%84ios02/"},{"title":"曾经的ios03","text":"今天的很多，有ARC 还有Oc的一些结构体和类， ARC ARC的判断准则：只要没有强指针指向对象，就会释放对象 ARC是编译器特性，并不是Oc语言特性 ARC的特点：不允许在调用与内存管理相关的方法（retain、release、retainCount）；可以重写dealloc方法，但不再调用父类的dealloc方法 @property的参数：strong 成员变量是强指针（用于Oc对象）；weak成员变量是弱指针（用于Oc对象）；assing 用于非Oc对象——就是将以前的retain改为strong 强指针：默认情况下，指针都是强类型 __strong； 弱指针：__weak 循环引用：一端用strong 一段用weak block 定义block变量： 12int (^myBlock) (int, int);void (^myBlock)(); 使用block封装代码： 123456 ^(int a, int b){ return a + b; } ^(){ NSLog(@”_____”);} 访问外部变量 默认是可以访问的，但是不能修改；要修改时，要在声明变量时前面加上__block 使用typedef定义block类型 12345typedef int (^MyBlock) (int, int);MyBlock b;b = ^(int a, int b){ return a + b;} block和指向函数的指针很像 protocol 协议（protocol）的定义 123@protocol 协议名称//方法声明@end 如何遵守协议 类：在类声明时，在父类后加&lt;协议名1，协议名2&gt; 协议：就是在协议名后加&lt;协议名1，协议名2&gt; 协议中方法的声明的关键字 @required（默认）要求方法实现，不实现就会有警告 @optional 不要求实现，怎么都不会有警告 定义一个变量时，限制变量保存对象遵守某个协议： 类名&lt;协议名&gt; * 变量名； id&lt;协议名&gt; 变量名； ——如果保存的变量没有遵守相应的协议就会发出警告 在@property中要求成员变量遵守某一协议： 12@property (nonatomic,strong) 类名&lt;&lt;/span&gt;协议名&gt; ＊成员名；@property (nonatomic,strong) id&lt;&lt;/span&gt;协议名&gt; 成员名； 协议可以定义在单独的.h文件中，也可以定义在某个类中；（如果协议自由某一个类使用，应该把他定义在该类中；都个类使用一个协议，就要单独写） Oc的结构体 包括 1234NSRange(location length)NSPoint\\CGPointNSSize\\CGSizeNSRect\\CGRect(CGPoint CGSize) 12345678// range// @”I love oc”; love 的范围NSRange r1 = {2, 4};NSRange r2 = {.location = 2, .length = 4};NSRange r3 = NSMakeRange(2, 4); 一般都用这个// 查找某个字符串在str中的位置NSRange range = [str rangeOfString:@”lo”];// 如果没有找到length＝0、location＝－1 12345678910// 点CGPoint p1 = NSMakePoint(10, 10);NSPoint p2 = CGPointMake(10, 10);// 长度和宽度NSSize s1 = NSMakeSize(10,5);CGSize s2 = CGSizeMake(10, 5);// 矩形CGRect r1 = CGRectMake(0, 0, 10, 5);CGRect r2 = {{0, 0}, (10, 5)};CGRect r3 = {p1, s1}; OC的几个类 字符串类NSString和NSMutableString 12345678910111213141516171819// 字符串的创建NSString *s1 = @”Jack”;NSString *s2 = [[NSString alloc] initWithString:@”Jack”];NSString *s3 = [[NSString alloc] initWithFormat:@”age is %d”,12];NSString *s4 = [[NSString alloc] initWithUTF8String:”Jack”;càOcconst char * cs = [s4 UTF8String];NSString *s5 = [[NSString alloc] initWihtContentsOFFile:@”文件路径” encoding:NSUTF8StringEncoding erroc:nil];NSString *s6 = [[NSString alloc] initWithContentOfURL:@”资源路径” encoding:NSUTF8StringEncoding error:nil];// 字符串的文件操作[@”xiuxiu” writeToFile:@”文件路径” atomically:YES encoding:NSUTF8StringEncoding error:nil];[@”xiuxiu” writeToURL:@”资源路径” atomically:YES encoding:NSUTF8StringEncoding error:nil];// 可变字符串NSMutableString *s = [NSMutableString stringWuthFormat:@”xiuxiu”];[s appendString:@”shilin”];// 不可变字符串也可以拼接但会返回一个新的字符串NSString *s2 =@”xiu”;NSString *s3 = [s2 stringByAppendingString:@”shilin”]; 数组类NSArray和NSMutableArray 123456789101112131415161718192021// Oc数组不能存放nil只能放Oc对象，不能放基本数据类型// 数组创建NSArray *a1 = [NSArray array];//a1永远都是空的NSArray *a2 = [NSArray arrayWithObjict:@”Jack”];NSArray *a3 = [NSArray arrayWithobjects:@”xiu”,@”shi”,nil];// 后面必须加上nilNSArray *a4 = @[@”xiu”,@”shi”,@”lin”];// 快速创建数组NSLog(@”%ld”,a3.count);// 数组元素个数// 元素访问NSLog(@“%@”,[a3 objectAtIndex:1]);NSLog(@”%@”,a3[0]);// 数组的遍历for(int i=0;ifor(id obj in a) obj;[a enumerateObjectUsingBlock:^(id obj, NSUInteger idx,BOOL *stop){obj}//stop控制是否遍历// 可变数组NSMutableArray *a = [NSmutableArray arrayWithObject:@”rose”, @”jim”, nil];[a addObject:@”xx”];[a removeAllObjects];[a removeObject:@”xx”];[a removeObjectAtIndex:0];// 可变数组不能使用快速创建数组的方法 NSSet:没有顺序，其他与数组一样的 1234567NSSet *s = [NSSet set];NSSet *s2 = [NSSet setWithObjects:@”xiu”,@”shi”,nil];NSString *s = [s2 anyObject];// 随机取出元素NSLog(@”%ld”,s2.count);NSMutableSet *s3 = [NSMutableSet set];[s3 addObject:@”lin”];// 添加元素[s3 removeObject:@”xiu”];// 删除 NSDictionary 123456789101112131415161718192021// 键值对（python中的字典）// 创建NSDictionary *d = [NSDictionary dictionaryWithObject:@”jack” forKey:@”name”];NSArray *k = @[@”name”,@”qq”];NSArray *obj = @[@”xiu”,@”3213”];NSDictionary *d2 = [NSDictionary dicationaryWithObjects:obj forKeys:k];NSDictionary *d3 = [NSDictionary dicationaryWithObjectsAndKeys:@”xiu”:@”name”,@”23123”:@”qq”,nil];NSDicationary *d4 = @{@”name”:@”xiu”,@”qq”:@”21312”};id obj = d4[@”name”];//--xiud4.count;//键值对的个数可变字典NSMutableDicationary *d = [NSMutableDicationary dicationary];[d setObject:@”xiu” forKey:@”name”];NSMutableDicationary *d2 = @{@”name”:@”xiu”};//可以快速创建[d removeObjectForKey:@”name”];//字典的键不能有相同的//字典遍历for (int i=0;iNSString *key = keys[i] NSString *obj = d [key][d enumrateKeysAndObjectsUsingBlock:^(id key,id obj,BOOL *stop){key obj} NSNumber 12345把基本数据类型包装成Oc对象NSNumber *n = [NSNumber numberWithInt:10];int a = [n intValue];@10;//快速包装包装成Oc对象就可以放到数组、字典中 NSValue 1234NSnumber继承自NSValue// 将结构体包装成Oc对象CGPoint p = CGPointMake(2,2);NSValue *v = [NSValue valueWithPoint:p]; NSDate 1234567NSDate *d = [NSDate date];// 直接打印d会打印零时区的时间，北京是东八区// 日期格式化NSDateformatter *df = [[NSDateFormatter alloc] init];df.dateFormat = @“yy-MM-dd HH:mm:ss”;NSString *s = [df stringFromDate:d];NSLog(@”%@”,str);","link":"/2015/10/03/%E6%9B%BE%E7%BB%8F%E7%9A%84ios03/"},{"title":"曾经的ios04","text":"iOS学习061-今天完成UIScrollView的小例子2-实现图片的捏合缩放，1103-scrollview01，拖一个UIScrollView在控制器的view上，在UIScrollView上添加一个UIImageView，添加一张大的图片，把UIIamgeView的长宽设置成图片的宽度，3-先实现图片的滚动，设置scrollview的contentSize的大小为UIImageView的size大小，就能实现滚动4-将UIScrollView的代理设置成控制器self，并让控制器遵守 ，并让控制器实现协议中的viewForZoomingInScrollView:方法，返回要实现缩放的控件，并要设置ScrollView的minimumZoomScale和maximumZoomScale(成倍的)，就可以实现缩放了5-喜马拉雅简单实现，1103-scroolview02，主界面主要是UIScrollView的几个属性的应用，先直接把值写上了。 12345self.scrollView.contentSize = CGSizeMake(0, 560);self.scrollView.contentInset = UIEdgeInsetsMake(64, 0, 44, 0);self.scrollView.contentOffset = CGPointMake(0, -64); 6-图片轮播的实现，1103-scrollview03，在控制器的view上放一个UIScrollView，宽度是控制器view的宽度，高度调整合适 7-通过代码生成一定数量的UIIamgeView，并设置图片 8-设置scrollview的pagingEnabled＝YES，会自动分页 9-设置自动滚动，定时器，将改变放到控制器中 10-当你拖住图片时，定时器会累积时间，松开后会变好几页，当你按住图片时，要停止定时器，松开后再开启定时器，要将定时器开启，用到代理 11-使用Page Control增强效果，设置pagecontrol的numberOfPages等于图片数，在changeImage方法中设置当前页 12-基本上功能就实现了 做的比较简单，没有什么特殊的知识，之前都学习过了，后来把图片轮播和喜马拉雅综合一起，没怎么写注释，把代码贴出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// ViewController.m// 1103-scrollview04//// Created by 修修 on 15/11/3.// Copyright © 2015年 cn.Xsoft. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController () &lt;&lt;/span&gt;UIScrollViewDelegate&gt;@property (weak, nonatomic) IBOutlet UIScrollView *bigScroll;@property (weak, nonatomic) IBOutlet UIScrollView *smallScroll;@property (weak, nonatomic) IBOutlet UIPageControl *pageControl;@property (weak, nonatomic) IBOutlet UIButton *lowBtn;@property (weak, nonatomic) IBOutlet UIView *topView;@property (weak, nonatomic) IBOutlet UIView *lowView;@property (nonatomic, strong) NSTimer *time;@end@implementation ViewControllerconst int count = 5;- (void)viewDidLoad { [super viewDidLoad]; CGFloat interval = 10; CGFloat scrollH = self.lowBtn.frame.origin.y + interval + self.lowBtn.frame.size.height; self.bigScroll.contentSize = CGSizeMake(0, scrollH); self.bigScroll.showsVerticalScrollIndicator = NO; CGFloat insetTop = self.topView.frame.size.height - self.smallScroll.frame.origin.y + interval; CGFloat insetLow = self.lowView.frame.size.height; self.bigScroll.contentInset = UIEdgeInsetsMake(insetTop, 0, insetLow, 0); self.bigScroll.contentOffset = CGPointMake(0, 0 - insetTop); CGFloat imageW = self.smallScroll.frame.size.width; CGFloat imageH = self.smallScroll.frame.size.height; for (int i = 0; i &lt; count; i++) { UIImageView *image = [[UIImageView alloc] init]; NSString *imagename = [NSString stringWithFormat:@&quot;img_0%d&quot;, i + 1]; image.image = [UIImage imageNamed:imagename]; CGFloat imageX = i * imageW; image.frame = CGRectMake(imageX, 0, imageW, imageH); [self.smallScroll addSubview:image]; } self.smallScroll.showsHorizontalScrollIndicator = NO; self.smallScroll.contentSize = CGSizeMake(count *imageW, 0); self.smallScroll.pagingEnabled = YES; self.pageControl.numberOfPages = count; self.smallScroll.delegate = self; self.time = [NSTimer scheduledTimerWithTimeInterval:1.5 target:self selector:@selector(changeImage) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:self.time forMode:NSRunLoopCommonModes];}- (void)changeImage { if (self.pageControl.currentPage == count - 1) { self.pageControl.currentPage = 0; } else { self.pageControl.currentPage++; } CGFloat changeX = self.smallScroll.frame.size.width * self.pageControl.currentPage; [self.smallScroll setContentOffset:CGPointMake(changeX, 0) animated:YES];}- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{ self.time = [NSTimer timerWithTimeInterval:1.5 target:self selector:@selector(changeImage) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:self.time forMode:NSRunLoopCommonModes];}- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{ [self.time invalidate]; self.time = nil;}- (void)scrollViewDidScroll:(UIScrollView *)scrollView{ if (self.time) return; self.pageControl.currentPage = (scrollView.contentOffset.x + scrollView.frame.size.width * 0.5) / scrollView.frame.size.width;}@end","link":"/2015/10/04/%E6%9B%BE%E7%BB%8F%E7%9A%84ios04/"},{"title":"曾经的ios05","text":"iOS学习07学习一个新的控件UITableView，下面简称tableview1-UITableView的数据源和代理，使用tableview显示数据要绑定他的数据源，监听tableview上的tableviewcell事件要指定代理。 都有两种方式：设置他的属性dataSource，或者拖线2-绑定数据源就要遵守数据源的协议并实现相应的方法3-tableview可以展示单组数据，也可以分组展示数据，tableview有两种样式UITableViewStylePlain和UITableViewStyleGrouped(分组比较明显)4-协议的几个方法： 123- (NSInteger)numberOfSectionInTableView:(UITableView *)tableView; //返回一共有多少组数据，传入当前的tableview- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; // 返回每组有多少行数据，传入单前的tableview和当前的组序号- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; // 每一行显示的内容是什么，会返回一个UITableViewCell，就是tableview的一行。传入当前的tableview和NSIndexPath(组序号，列序号) 5-介绍一下UITableViewCell，他就是UITableView的一行6-UITableViewCell中有一个默认的子视图：contentView，可以使用cell的accessoryView属性来指定一些辅助视图7-contentView下还有三个子视图textLabel、detailTextLabel和UIIamgeView，通过设置当前cell的UITableViewCellStyle的属性来决定显示子视图的位置8-几个小例子 汽车品牌：（没贴模型的代码，模型就是之前学过的，改下属性就好） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//// ViewController.m// 1104-tableview01//// Created by 修修 on 15/11/4.// Copyright © 2015年 cn.Xsoft. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;LSCargroup.h&quot;@interface ViewController () &lt;&lt;/span&gt;UITableViewDataSource&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView; @property (nonatomic, strong) NSArray *cargroups;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; }# pragma mark - getter方法懒加载- (NSArray *)cargroups{ if (_cargroups == nil) { NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;cars_simple.plist&quot; ofType:nil]; NSArray *array = [NSArray arrayWithContentsOfFile:path]; NSMutableArray *temp = [NSMutableArray array]; for (NSDictionary *dict in array) { LSCargroup *group = [LSCargroup cargroupWithDict:dict]; [temp addObject:group]; } _cargroups = temp; } return _cargroups;}# pragma mark - 数据源方法- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{ return self.cargroups.count;} - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ // 拿到当前的模型，模型中cars数组的长度就是每组的行数 LSCargroup *ss = _cargroups[section]; return ss.cars.count;} - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ static NSString *ID = @&quot;car&quot;; // 性能优化 // 先在缓存池中寻找有没有可以循环利用的cell，按照标识ID来寻找 UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:ID]; // 要是找不到，就要自己去创建一个 if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID]; } // 给cell添加数据 // 拿到模型 LSCargroup *ss = _cargroups[indexPath.section]; NSString *carname = ss.cars[indexPath.row]; // 赋值 cell.textLabel.text = carname; return cell;} - (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section{ // 拿到模型 LSCargroup *ss = _cargroups[section]; return ss.title;} - (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section{ // 拿到模型 LSCargroup *ss = _cargroups[section]; return ss.desc;}- (BOOL)prefersStatusBarHidden{ return YES;}@end一些关键的注释贴不出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//// ViewController.m// 1104-tableview02//// Created by 修修 on 15/11/5.// Copyright © 2015年 cn.Xsoft. All rights reserved.//#import &quot;ViewController.h&quot;#import &quot;SLHero.h&quot;@interface ViewController () &lt;&lt;/span&gt;UITableViewDataSource, UITableViewDelegate&gt; @property (nonatomic, strong) NSArray *heros;@property (weak, nonatomic) IBOutlet UITableView *tableView;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; // 设置每一行的高度，默认44 self.tableView.rowHeight = 60;}#pragma mark - getter方法重写- (NSArray *)heros{ if (_heros == nil) { NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;heros.plist&quot; ofType:nil]; NSArray *herostemp = [NSArray arrayWithContentsOfFile:path]; NSMutableArray *tempary = [NSMutableArray array]; for (NSDictionary *dict in herostemp) { SLHero *hero = [SLHero heroWithDict:dict]; [tempary addObject:hero]; } _heros = tempary; } return _heros;}#pragma mark - 数据源方法// 可以不写，默认就是一组- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{ return 1;}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return self.heros.count;}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ // 设置一个cell的唯一标识 NSString * ID = @&quot;hero&quot;; // 在缓存池中寻找有没有可以重复利用的cell，并且标识是ID UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; // 如果没有找到，就自己创建一个cell，并让他的标识为ID if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; } // 设置cell显示的值 // 拿到当前的模型 SLHero *hero = self.heros[indexPath.row]; cell.textLabel.text = hero.name; cell.detailTextLabel.text = hero.desc; cell.imageView.image = [UIImage imageNamed:hero.icon]; // 返回cell return cell;}#pragma mark - 代理方法 - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{ // 取出当前的模型 SLHero *hero = self.heros[indexPath.row]; // 弹框，iOS9中Apple推荐使用的弹框方法，之前的UIAlertView在iOS9不适用 // 先定义一个弹框，标题、显示的信息、优先选取的style UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;英雄信息&quot; message:nil preferredStyle:UIAlertControllerStyleAlert]; // 在定义弹框的按钮，标题、形式、一个block（用来写按钮的点击方法） // 取消按钮 UIAlertAction *cancelBtn = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) { }]; // 修改按钮 UIAlertAction *deBtn = [UIAlertAction actionWithTitle:@&quot;修改&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) { // 拿到弹框上的textField UITextField *textField = alert.textFields[0]; // 修改模型数据， hero.name = textField.text; // 局部刷新数据 [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom]; }]; // 给弹框添加一个UITextField，显示英雄的名字 [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) { textField.text = hero.name; }]; // 将两个按钮放上去 [alert addAction:cancelBtn]; [alert addAction:deBtn]; // 显示弹框 [self presentViewController:alert animated:YES completion:nil];}@end文档注释贴不出来，，，，","link":"/2015/10/05/%E6%9B%BE%E7%BB%8F%E7%9A%84ios05/"},{"title":"曾经的ios06","text":"好久没写了，现在一起看完然后写的总结，代码没有在新浪发，感觉新浪对代码的支持不是很好，所以我把代码都放到了csdn，在这写个链接吧自定义cell的代码01自定义cell的代码02 iOS学习08总结UITableViewCell的基本用法 使用xib自定义cell 如果每一行cell都一样，且系统提供的cell不能满足要求，就可以创建xib文件自定义cell， 为xib中的cell添加一个类，再类中解析xib创建自定义的cell，提供给别人用，还要让类拥有相应的模型， 在cell的类中实现cell的重用 在控制器的返回cell的方法中，初始化cell，并为cell传递模型，设置数据 关于cell重用的问题，当在缓存池中拿到cell的时候，要将控件的状态调整正确 使用代码自定义cell 当每一行的cell的高度不确定，内部显示的内容不确定时，就要使用代码创建我们需要的cell 创建一个SLOwnCell的类，用来自定义cell，继承自我们系统的UITableViewCell 通过重写父类的init方法，向cell中添加自己的控件，在这里设置控件不变的数据，（主要思想就是先将要显示的所有控件加进去，之后再根据情况设置是否显示–是否设置控件的Frame） 提供一个类方法，创建cell在类方法中实现cell的重用，调用init初始化cell 每个cell中的控件数据不同，所以每个控件位置和每个cell的高度就不一定，所以我们要创建一个位置模型（SLXxxFrame） 这个位置模型中包含数据模型，和之后每个控件的（CGRect）xxxFrame 在计算frame的时候，要计算文本在屏幕的位置，NSString中有一个对象方法， 在初始化cell后为SLOwnCell类中的位置模型传递值，在位置模型的setter方法的重写中，为控件设置位置和数据 QQ聊天 也是用代码创建cell，就说一下几个重要的 相同时间就显示一个：在消息模型中声明一个BOOL型标识sameTime。在控制器的模型的getter方法中，使用定义的可变数组可以取出上一个元素，与当前时间判断，相同就让sameTime =YES；在设置time控件的Frame的时候，就不设置值。 聊天气泡：涉及到图片的拉伸，要保证图片的边缘不变，就要把中心放大，UIImage提供了一个方法 通知机制： 123456789101112131415161718192021222324252627// 通知：NSNotification，一般包含三个属性：(NSString *)name通知的名称、(id)object通知的发布者、(NSDictionary *)userInfo通知的一些额外信息；初始化一个通知+ (instancetype)notificationWithName:(NSString *)aName object:(id)anObject;+ (instancetype)notificationWithName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;- (instancetype)initWithName:(NSString *)name object:(id)object userInfo:(NSDictionary *)userInfo;&gt;通知中心：NSNotificationCenter，管理通知的接收，注册监听器；发布通知：- (void)postNotification:(NSNotification *)notification; // 发布一个notification通知，可在notification对象中设置通知的名称、通知发布者、额外信息等 - (void)postNotificationName:(NSString *)aName object:(id)anObject; // 发布一个名称为aName的通知，anObject为这个通知的发布者 - (void)postNotificationName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;// 发布一个名称为aName的通知，anObject为这个通知的发布者，aUserInfo为额外信息// 监听器：用来接收消息，监听是否发出我想要的消息，注册监听器，- (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject;observer：监听器，即谁要接收这个通知aSelector：收到通知后，回调监听器的这个方法，并且把通知对象当做参数传入aName：通知的名称。如果为nil，那么无论通知的名称是什么，监听器都能收到这个通知anObject：通知发布者。如果为anObject和aName都为nil，监听器都收到所有的通知一般在监听器销毁之前取消注册（如在监听器中加入下列代码）：- (void)dealloc { //[super dealloc]; 非ARC中需要调用此句 [[NSNotificationCenter defaultCenter] removeObserver:self];} UIDecive的通知：通过[UIDevice currentDevice]可以获取这个单粒对象UIDecive会不断地发布一些通知：设备旋转、电池状态改变、电池电量改变、近距离传感器 键盘的通知： 123456&gt;UIKeyboardWillShowNotification // 键盘即将显示&gt;UIKeyboardDidShowNotification // 键盘显示完毕&gt;UIKeyboardWillHideNotification // 键盘即将隐藏&gt;UIKeyboardDidHideNotification // 键盘隐藏完毕&gt;UIKeyboardWillChangeFrameNotification // 键盘的位置尺寸即将发生改变&gt;UIKeyboardDidChangeFrameNotification // 键盘的位置尺寸改变完毕 发送聊天消息：键盘属于调出他的那个对象（UITextFiled），通过他的一些属性可以修改键盘的一些属性，在UITextFiled的代理中有监听键盘点击事件的代理方法，可以让控制器称为代理，完成发送消息 静态cell将stroyboard中的viewController换成tableViewController，并让tableViewController的类指向默认的SLViewController，修改其中的tableview，让他变成静态，添加静态的cell","link":"/2015/10/06/%E6%9B%BE%E7%BB%8F%E7%9A%84ios06/"},{"title":"曾经的ios07","text":"这些天一直在忙期末复习的事，耽误了好些天，接下的考试周，课少了就可以有更多时间看视频和写代码了，下面是今天写的一点点。 iOS学习09几个常用的控件1206-PickerVIew 城市选择数据源：UIPickerViewDataSource设置有多少列和多少行 (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView; (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component;代理：UIPickerViewDelegate设置每一列每一行显示的是什么内容 (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component; (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component; (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component; (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view; (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component; 刷新数据(void)reloadAllcomponent;// 所有列(void)reloadComponent:(NSInteger)component;//指定列主动选择第component列和第row行(void)selectRow:(NSInterger)row inComponent:(NSInteger)component animated:(BOOL)animated;得到第component列的选中行(NSInteger)selectdRowInComponent:(NSinteger)component;1206-UIDatePicker @property (nonatomic) UIDatePickerMode datePickerMode;// datePicker的显示模式 @property (nonatomic, retain) NSLocale *locale;// 显示的区域语言 2.监听UIDatePicker的选择 因为UIDatePicker继承自UIControl,所以通过addTarget:…监听 1206-Picker作业（综合，键盘工具条） 通过textfield的inputView属性更改键盘 textFieid的inputAccessoryView属性设置键盘上面的工具条 注：加深对代理使用的理解 自己写这些就是想以后可以有东西复习，并不能给比别人带来什么，主要是为了自己，一直坚持吧！ 跳一节，上一个写的太散了，就先不放这里了iOS11一、控制器的多种创建过程控制器SLViewController：UIVIewController*代码创建：SLViewController *con = [SLViewController alloc] init];// init直接成为根控制器*storyboard创建（不使用main.storyboard）先加载storyboard文件UIStoryboard *sb = [UIStoryboard storyboardWithName:@“sl” bundle:nil];然后初始化storyboard中的控制器SLViewController *con = [sb instantiateInitialViewController];//storyboard箭头指向的控制器SLViewController *con = [sb instantiateViewControllerWithindetifier:@“sl”];//标识为sl的控制器*xib文件创建SLViewController *con = [[SLViewcontroller alloc] initWithNibName:@“SLViewController”];二、控制器View的创建（SLViewController）if loadView ：根据oadView的代码创建；else if storyboard ：根据storyboard描述创建else if nibName：根据nibName对应的xib创建else if SLView.xib：根据SLView.xib创建else if SLViewController.xib：根据SLViewController.xib创建else :创建一个空的view控制器的view是延时加载的，三、多控制器的管理*UINavigationController在控制器上方会有一个导航栏（设置） 初始化UINavigationController设置UIWindow的根控制器为UINavigationController使用push方法添加子控制器UINavigationController以栈(先进后出)的形式保存子控制器，总是显示栈顶控制器的viewNSArray *viewControllers;/NSArray *childViewController;使用push方法，把子控制器压入栈 (void)pushViewController:(UIViewController)viewController animated:(BOOL)animated;使用pop方法可以移除子控制器 (UIViewController *)popViewControllerAnimated:(BOOL)animated;// 移除栈顶的控制器 (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;// 回到指定的控制器 (NSArray *)popToRootViewControllerAnimated:(BOOL)animated;// 回到根控制器导航栏的使用显示的内容由栈顶控制器的navigationItem属性决定UINavigationItem有以下属性：@property(nonatomic, retain)UIBarButtonItem *backBarButtonItem;// 左上角的返回按钮@property(nonatomic, retain)UIView *titleView;// 中间的标题视图@property(nonatomic, copy)NSString *title;// 中间标题文字@property(nonatomic, retain)UIBarButtonItem *leftBarButtonItem;// 左上角视图@property(nonatomic, retain)UIBarButtonItem *rightBarButtonItem;// 右上角视图使用storyboard时可以直接拖线实现跳转，在两个控制器之间会有一条线，这条线是一个UIStoryboardSegue对象(segue)每个segue都有三个属性：identifier(唯一标识)、sourceViewController(来源控制器)、destinationViewController(目标控制器)segue有自动跳转和手动跳转 当点击某个控件不需要做一些事情的事后，就可以直接拖线，实现跳转如果需要在跳转前做一些判断(登陆)，需要手动跳转。将来源控制器拖线到目标控制器，为segue绑定唯一标识，执行[self performSegueWithIdentifier:@“login2other” sender:nil];控制器之间的数据传递顺传： (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender;// 在准备跳转前调用，通过segue拿到目标控制器，各塔传递一些数据逆传：通过代理，让来源控制器成为目标控制器的代理，当目标控制器点击出栈的时候通知代理，并将相应的数据传过去*UITabBarController在控制器的底部有一个导航条（QQ） 初始换UITabBarController设置UIWindow的根控制器为UITabBarController使用addChildViewController添加子控制器UITabBarController会根据子控制器的个数将导航栏均分成几个部分，点击后就会实现自动跳转UITabBarItem决定每个部分的内容，有几个属性：NSString *title(标题文字)、UIImage *image(图标)、UIImage *selectedImage(选中图标)、NSString *badgeValue(提醒数字)—-通常的UI框架是使用一个UITabBarController管理几个UINavigationController，再由每个UINavigationController管理多个子控制器*Modal显示控制器（多控制器），控制器会在底部向上钻出 (void)presentViewController:(UIViewController *)viewControllerToPresent animated:(BOLL)flag completion:(void (^) (void))completion;// 展示控制器 (void)dismissViewContollerAnimated:(BOOL)flag completion(void (^) (void))completion;// 退出控制器一般modal方法显示的控制器应该与当前控制器没有太多的关联四、应用程序目录结构（应用沙盒）Documents：保存应用运行时生成的需要持久化的数据，iTune同步设备时会备份数据tmp：保存应用运行时所需要的临时数据，系统会自动清理该目录文件，iTunes不会被分该目录LIbrary/Caches：保存应用运行时生成的需要持久化的数据，iTunes不会备份该目录，一般是体积较大的文件，不需备份的非重要数据Library/Preference：保存应用的偏好设置，iTunes会备份该目录五、沙盒目录获取NSHomeDirectory();stringByAppendingPathComponment:@“”;//路径拼接六、数据存储1.通过plist文件存储（xml） 获得路径writeToFile:atomically:，只能归档NSString、NSArray、NSDictionary、NSData、NSNumberarrayWithContentOfFile:……2.通过preference（偏好设置）单粒对象NSUserDefaults *def = [NSUserDefault standardUserDefaults];[def setObject: forKey:];[def stringForKey];……[def synchornize];强制写入文件中（强退）3.NSKeyedArchiver归档（NSCoding）获得路径[NSKeyedArchiver archiverRootObject: toFile: ];// 归档[NSKeyedUnrchiver unarchiverRootObjectWithFile: ];// 读取第一种方式的类型可以直接归档，自定义的类需要遵守协议并实现相应的方法才能使用在encodeWithCoder:中使用encodeObject:forKey:方法归档实例在initWithCoder:中使用decodeObject:forKey:方法解析实例存在继承关系的归档，父类归档自己的属性，子类重写时调用父类的方法，再归档自己的属性4.SQLite3 // 嵌入式数据库，后面讲5.Core Data // 对SQLite3的封装，C语言API","link":"/2015/10/07/%E6%9B%BE%E7%BB%8F%E7%9A%84ios07/"},{"title":"模拟器路径和相册文件夹（iOS）","text":"在 mac 的访达中直接访问模拟器的相册图片 模拟器地址1~/Library/Developer/CoreSimulator/Devices/ 使用 cmd + shift + g 打开前往文件夹，或者使用 cd 命令，可以看到以设备 udid 命名的模拟器设备文件夹 模拟器设备名终端命令，列出所有的设备，型号、iOS版本、状态 …1xcrun simctl list devices 通过 grep 做些筛选，注意大小写（-i），空格的转义，具体可以了解下 grep 的使用12345// 开启的xcrun simctl list devices | grep Booted// 指定型号xcrun simctl list devices | grep iPhone\\ 8 也可以在 Xcode &gt; Window &gt; Devices and simulators &gt; Simulators 的指定设备页面找到 Identifier 相册文件夹其中 &lt;device UDID&gt; 对应你需要打开的模拟器，在终端使用 open，或者 cmd + shift + g，就可以看到相册的图片了，添加、删除也可以了1open ~/Library/Developer/CoreSimulator/Devices/&lt;device UDID&gt;/data/Media/DCIM/100APPLE 参考","link":"/2018/09/25/%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%86%8C%E6%96%87%E4%BB%B6%E5%A4%B9/"}],"tags":[{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"kappa","slug":"kappa","link":"/tags/kappa/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"gitea","slug":"gitea","link":"/tags/gitea/"},{"name":"selfhost","slug":"selfhost","link":"/tags/selfhost/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"hacker","slug":"hacker","link":"/tags/hacker/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"模拟器","slug":"模拟器","link":"/tags/%E6%A8%A1%E6%8B%9F%E5%99%A8/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"cookbook","slug":"cookbook","link":"/tags/cookbook/"},{"name":"datastruct","slug":"datastruct","link":"/tags/datastruct/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Objective-C","slug":"Objective-C","link":"/tags/Objective-C/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"RPC","slug":"RPC","link":"/tags/RPC/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"unary","slug":"unary","link":"/tags/unary/"},{"name":"Ad Hoc","slug":"Ad-Hoc","link":"/tags/Ad-Hoc/"},{"name":"objc","slug":"objc","link":"/tags/objc/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"gitbook","slug":"gitbook","link":"/tags/gitbook/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"gzip","slug":"gzip","link":"/tags/gzip/"},{"name":"openshift","slug":"openshift","link":"/tags/openshift/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"think","slug":"think","link":"/tags/think/"}],"categories":[{"name":"architecture exam","slug":"architecture-exam","link":"/categories/architecture-exam/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"technology","slug":"technology","link":"/categories/technology/"},{"name":"wAyS","slug":"wAyS","link":"/categories/wAyS/"},{"name":"host","slug":"host","link":"/categories/host/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}],"pages":[{"title":"关于","text":"简介A CURD Developer 联系我 Email: xiushilin@hotmail.com 微信：base64(eDIwMjB5eWc) 致谢🌸期待能有机会和您共事。","link":"/about/index.html"}]}